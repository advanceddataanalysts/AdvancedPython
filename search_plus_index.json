{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is for advanced data analysts ... "},"Databases/":{"url":"Databases/","title":"Databases","keywords":"","body":"Introduction mysql hive presto mongodb redis "},"DataAnalystHelper/":{"url":"DataAnalystHelper/","title":"DataAnalystHelper","keywords":"","body":"Introduction 本项目从BI层面提供数据服务支持方面, 封装了常用方法 使数据分析师在日常工作中快速搭建数据服务来专注业务逻辑 代码主要对以下几大点做封装 数据库连接查询(Mysql , Hive) 数据表生成(Mysql中间表) DataFrame常用方法二次封装(时间函数, 输出Excel, merge...) 输出内容相关(html模板渲染, 钉钉自定义机器人) ...... 具体代码请前往 https://github.com/advanceddataanalysts/AdvancedPython "},"GitTips/":{"url":"GitTips/","title":"GitTips","keywords":"","body":"GitTips "},"GitTips/GitCommon.html":{"url":"GitTips/GitCommon.html","title":"GitCommon","keywords":"","body":"Git 基本的使用 git push 之前先 git pull 1.查看状态 $ git status 2.从线上拉下来最新的与自己的进行合并 $ git pull $ git fetch --只拉取不合并 3.将自己的文件夹添加到暂存区 $ git add . 4.从暂存区将代码提交到 git本地仓库 $ git commit (--all) -m 'modify_reaon' 5.从本地仓库到远程仓库 $ git push [地址] [master(默认)] 6.设置用户名和邮箱 $ git config --global user.name(user.email) 'name/email' ## 1.取消文件修改 $ git checkout 2.查看提交日志 $ git log $ git log --oneline ##简洁版 4.查看所有版本提交日志 $ git reflog 3.回退版本(soft, mixed, hard, keep) $ git reset --hard $ git reset --hard 5.创建dev分支(刚创建时dev分支和master分支的东西是一样的) $ git branch dev 6.切换分支 $ git checkout dev 7.查看分支(输入命令打印后前面带*号的为当前分支) $ git branch 8.合并分支 $ git merge dev 9.删除分支(不能自己删除自己当前分支) $ git branch -d dev 10.生成公私钥(ssh) $ ssh-keygen -t rsa 11.将文件暂存起来放在暂存区(只能在add/commit之后才能暂存)(方便切换到其他分支工作) $ git stash 12.恢复暂存区文件 $ git stash apply (stash@{}n为第几个暂存区文件)(默认恢复最近的文件) $ git stash drop -- $ git stash pop (恢复最近的暂存区文件并删除缓存区中的该文件) $ git stash list (查看暂存区) 13.忽略提交(添加.gitignore文件) $ touch .gitignore $ vim .gitignore(编辑需要忽略的文件,支持正则) 14. 删除git全局配置项 $ git config --global --unset remote.origin.url git命令 Git-tips "},"GitTips/QuicklyBuildGitBook.html":{"url":"GitTips/QuicklyBuildGitBook.html","title":"QuicklyBuildGitBook","keywords":"","body":"GitBook建立并结合GitHub使用 1 安装npm 2 全局安装GitBook npm install -g gitbook-cli 3 本地创建项目 例如PythonCookBook 4 执行命令 gitbook init && gitbook serve (默认4000端口 , 可指定) 5 查看本地启动的服务 127.0.0.1:4000 6 本地创建需要上传到远程仓库的.md文件并上传到远程仓库 git init git remote add origin https://github.com/github账号/项目名(需与本地目录一致).git git add . git commit -m 'init' git push -u origin master 7 本地进行测试并将_book推到供他人访问的分支上 1. 本地gitbook serve启动本地gitbook服务生成静态资源文件 访问 http://127.0.0.1:4000 2. git push 3. git subtree push --prefix=_book origin gh-pages 8 让他人访问 下面地址(对应的个人名字跟文件名改掉) https://yanyanglong.github.io/PythonShare/ 9 图片及主题设置 图片 1. 图片本地保存到某个位置, 例如along.png放到 /PythonShare/image 中 2. 引用时将图片路径导入,默认当前路径为根文件夹路径 故引用图片路径为 /image/along.png 写法为 ![PNG](/image/along.png), 同时在md文件的最开始加入以下内容 --- typora-root-url: .. --- 主题设置 1. 根目录下创建 book.json 文件,\"plugins\": []中写入插件名即可, \"theme-comscore\"为gitbook中一个主题包 详细个性化配置参考 http://www.chengweiyang.cn/gitbook/customize/book.json.html 2. css配置, 如代码行web页面显示长度(下例为个人配置) 根目录下创建website.css 文件,写入 .page-inner {max-width: 1000px;padding: 2px 2px 2px 2px;} 在book.json中 加入 \"styles\": { \"website\": \"website.css\" } - "},"PythonShare/":{"url":"PythonShare/","title":"PythonShare","keywords":"","body":"PythonShare "},"PythonShare/Dictionary.html":{"url":"PythonShare/Dictionary.html","title":"Dictionary","keywords":"","body":"Dictionary Q 构建字典时 创建字典引用其他字典时,不知道key是否存在,如果key存在则去重 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: dic = {} def add_dic(pairs,dic): for key,value in pairs.items(): if key not in dic: dic[key] = [] dic[key].append(value) dic[key] = list(set(dic[key])) return dic add_dic(pairs=pairs,dic=dic) add_dic(pairs=pairs1,dic=dic) ## 方法二: ## 代码结构更清晰 from collections import defaultdict s_dict = defaultdict(set) def s_add_dic(pairs,dic): for key,value in pairs.items(): s_dict[key].add(value) return dic s_add_dic(pairs=pairs,dic=s_dict) s_add_dic(pairs=pairs1,dic=s_dict) Q 构建字典时 保证字典有序 ## 方法一: ## python3.6之后字典会按照构建顺序自动排序 dic = {} dic['a'] = 1 dic['b'] = 2 dic['c'] = 3 dic['d'] = 4 print(dic) ## {'a': 1, 'c': 3, 'b': 2, 'd': 4} ## 方法二: ## 必按照添加顺序排序 w+s ## OrderedDict内部维护了双向链表,根据加入顺序排列键的位置,但是大小是普通字典的2倍大 from collections import OrderedDict s_dic = OrderedDict() s_dic['a'] = 1 s_dic['b'] = 2 s_dic['c'] = 3 s_dic['d'] = 4 print(dict(s_dic)) ## {'a': 1, 'b': 2, 'c': 3, 'd': 4} Q 构建字典时 从已有的字典中提取子集 ## 字典推导式 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} dic = {key:value for key,value in pairs.items() if key in ['apple','orange']} print(dic) Q 构建字典时 字典映射 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: ## 构建新的字典对象/在原始字典上修改 new_pairs = dict(pairs1) new_pairs.update(pairs) print(new_pairs) ## 方法二: ## ChainMap使用原始字典映射,更改原始字典同步反应到映射对象上 from collections import ChainMap cm_pairs = ChainMap(pairs,pairs1) print({key:value for key,value in cm_pairs.items()}) ## 对ChaipMap对象的修改只会反映到第一个dict对象上, 反之亦然, 对字典的修改只有第一个的修改会反映到ChaipMap对象上 cm_pairs['tuberose'] = 99999999999999999999 print(cm_pairs,'\\n',pairs,'\\n',pairs1) pairs1['tuberose'] = 9999999888888888999999999999 print({key:value for key,value in cm_pairs.items()}) Q 对字典进行计算 将字典的key替换, value不变 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} ## 方法一: pairs['new_apple'] = pairs.pop('apple') ## 方法二: pairs.update({'new_apple':pairs.pop(\"apple\")}) Q 对字典进行计算 求value最值对应的key:value对 prices = {'A':2.22,'B':9.06,'C':0.06,'D':9.06,'E':0.06} print(max(prices)) ## 'E' ## 多条记录value相等时 按照第二个参数大小排序 print(max(zip(prices.values(),prices.keys()))) ## (9.06, 'D') ## 多条记录value相等时 取第一次出现的键值对 print(max(prices, key=lambda k: prices[k]), prices[max(prices, key=lambda k: prices[k])]) ## B 9.06 Q 对字典进行计算 求两个/多个字典的相同点 a_dict = {'x':1, 'y':2, 'z':3} b_dict = {'x':1, 'y':2, 'w':3} c_dict = {'x':1} print(a_dict.keys() & b_dict.keys()) ##{'x', 'y'} print(a_dict.keys() & b_dict.keys() & c_dict.keys()) ##{'x'} print(a_dict.items() & b_dict.items()) ## {('x', 1), ('y', 2)} c = {key:a_dict[key] for key in a_dict.keys() - {'z','w'}} print(c) ##{'x': 1, 'y': 2} Q 对字典进行计算 通过公共键对字典列表排序 rows = [{'fname':11, 'lname':2, 'uid':1003}, {'fname':111, 'lname':22, 'uid':1004}, {'fname':111, 'lname':222, 'uid':1002}, {'fname':11, 'lname':222, 'uid':1003},] ## 方法一: sorted(rows, key=lambda x:x['uid']) sorted(rows, key=lambda x:(x['fname'],x['lname'])) ## 方法二: ## 运行速度更快,性能好(max,min也同样支持) from operator import itemgetter sorted(rows, key=itemgetter('uid'), reverse=True) sorted(rows, key=itemgetter('fname','lname'),reverse=False) ## 方法三: ## 抓成df,排序结束再用df.to_dict()/df.to_json()转 import pandas as pd data = pd.DataFrame(rows) data.sort_values(by=['uid'],inplace=True) data.to_dict(orient='records') Q 对字典进行计算 根据键对数据进行分组 rows = [{'address':'zhongguancun', 'date':'07/01/2018'}, {'address':'putuo', 'date':'07/02/2018'}, {'address':'wangfujing', 'date':'07/01/2018'}, {'address':'jingan', 'date':'07/04/2018'},] ## 方法一: ## sort+itemgetter+groupby from operator import itemgetter from itertools import groupby rows.sort(key=itemgetter('date')) ##分组前需要先排序,因为groupby()只能检查连续的项 for key, value in groupby(rows, key=itemgetter('date')): print(key) for i in value: print(' ',i) ## 方法二: ## 转成df,groupby之后再转成字典 import pandas as pd data = pd.DataFrame(rows) for key,value in data.groupby(by=['date']): print(key,list(value.T.to_dict().values())) "},"PythonShare/DataStructure.html":{"url":"PythonShare/DataStructure.html","title":"DataStructure","keywords":"","body":"DataStructure * 解压 解压序列赋值给多个变量(作用可迭代对象) p = (4, 5) x, y = p data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] name, shares, price, date = data name, shares, price, (year, mon, day) = data s = 'Hello' a, b, c, d, e = s # 变量个数和序列元素的个数不匹配，会产生一个异常 p = (4, 5) x, y, z = p # 部分解压 data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] _, shares, price, _=data 解压可迭代对象赋值给多个变量 record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212') record = ('Dave', 'dave@example.com') record = ('Dave', 'dave@example.com','773-555-1212', '847-555-1212','773-555-1213', '847-555-1213') name, email, *phone_numbers = record phone_numbers #星号表达式也能用在列表的开始部分 *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current trailing, *current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false' uname, *fields, homedir, sh = line.split(':') 双向队列 deque:double-ended queue #双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。 #将队列的两端分别称为前端和后端，两端都可以入队和出队 栈:栈是一种后进先出的数据结构，我们可以借助list来实现栈 stack = [] stack.append(item1) # 入栈 stack.pop() # 出栈，返回结果是出栈元素 peak = stack[-1] # 返回栈顶元素 队列:队列是一种先进先出的数据结构，我们可以借助list来实现队列 queue = [] queue.append(item) # 入队 queue.pop(0) # 出队，返回结果是出队元素 在队列两端插入或删除元素时间复杂度都是 O(1) ， 而在列表的开头插入或删除元素的时间复杂度为 O(N) 。 from collections import deque q = deque(maxlen=3) q.append(1) q.append(2) q.append(3) q.append(4) q.append(5) #q.appendleft(6) ###默认从右边 q.clear() #清空队列 q.count(n) #在队列中统计元素的个数，n表示统计的元素 q.extend(n) #从右边扩展队列，n表示扩展的队列 q.extendleft(n) #从左边扩展队列，n表示扩展的队列 q.pop() #队尾元素删去 q.popleft() #队头元素删去 Heap & Heapq 查找最大或最小的 N 个元素 堆： 1.建立在完全二叉树的基础上(若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数， 第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。) 2.排序算法的一种，也是稳定效率最高的一种 3.可用于实现STL中的优先队列(priority_queue) STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。 它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的 **优先队列**：一种特殊的队列，队列中元素出栈的顺序是按照元素的优先权大小，而不是元素入队的先后顺序 4.两类： a.最大堆： ①根的值大于左右子树的值 ②子树也是最大堆 b.最小堆： ①根的值小于左右子树的值 ②子树也是最小堆 该模块提供了堆排序算法的实现,heapq有两种方式创建堆， 一种是使用一个空列表， 然后使用heapq.heappush()函数把值加入堆中，另外一种就是使用heap.heapify(list)转换列表成为堆结构 ##插入 import heapq #载入heap库，heap指的是最小堆 nums = [2, 3, 5, 1, 54, 23, 132] heap = [] for num in nums: heapq.heappush(heap, num) # 加入堆 print(heap[0]) # 如果只是想获取最小值而不是弹出，使用heap[0] print([heapq.heappop(heap) for _ in range(len(nums))]) # 堆排序结果 heap= [] nums = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(nums) print(nums) print([heapq.heappop(heap) for _ in range(len(nums))]) import math from io import StringIO def show_tree(tree, total_width=36, fill=' '): \"\"\"Pretty-print a tree.\"\"\" output = StringIO() last_row = -1 for i, n in enumerate(tree): if i: row = int(math.floor(math.log(i + 1, 2))) else: row = 0 if row != last_row: output.write('\\n') columns = 2 ** row col_width = int(math.floor(total_width / columns)) output.write(str(n).center(col_width, fill)) last_row = row print(output.getvalue()) print('-' * total_width) print() data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) ##删除 #heapq.heappop() data = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(data) heap = [] while data: i=heapq.heappop(data) print('pop %3d:' % i) show_tree(data) heap.append(i) print(heap) import heapq nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] # print(heapq.nlargest(3, nums)) # Prints [42, 37, 23] # print(heapq.nsmallest(3, nums)) # portfolio = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price']) expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price']) ###最小堆转最大堆 只用对元素取负，按照最小堆的方式存储，取出来的值只要再取负，就是最大值了。即push(e)改为push(-e)，pop(e)为-pop(e) data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) heap1 = [] while heap: i=-1 * heapq.heappop(heap) print('pop %3d:' % i) show_tree(data) heap1.append(i) print(heap1) ####最大堆 实现一个优先级队列 import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] class Item: def __init__(self, name): self.name = name def __repr__(self): return 'Item({!r})'.format(self.name) q = PriorityQueue() q.push(Item('foo'), 1) q.push(Item('bar'), 5) q.push(Item('spam'), 4) q.push(Item('grok'), 1) q.pop() q.pop() q.pop() q.pop() "},"PythonShare/Regex.html":{"url":"PythonShare/Regex.html","title":"Regex","keywords":"","body":"Regex 模式匹配: 模式匹配是数据结构中字符串的一种基本运算, 给定一个子串, 要求在某个字符串中找出与该子串相同的所有子串 tips: 正则表达式使用反斜杠（'\\'）来表示特殊形式，或者把特殊字符转义成普通字符. 而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突. 比如说，要匹配一个字面上的反斜杠，正则表达式模式不得不写成 '\\\\\\\\'，因为正则表达式里匹配一个反斜杠必须是 \\\\ ，而每个反斜杠在普通的 Python 字符串里都要写成 \\\\ . 解决办法是对于正则表达式样式使用 Python 的原始字符串表示法: 在带有 'r' 前缀的字符串字面值中，反斜杠不必做任何特殊处理. 因此 r\"\\n\" 表示包含 '\\' 和 'n' 两个字符的字符串，而 \"\\n\" 则表示只包含一个换行符的字符串. 样式在 Python 代码中通常都会使用这种原始字符串表示法来表示. import re ## 不带'r'前缀 a = '''aaa\\\\bbbb''' re.split('\\\\\\\\',a) # ['aaa', 'bbbb'] ## 带'r'前缀 re.split(r'\\\\',a) # ['aaa', 'bbbb'] 正则表达式语法 用来检查某个字符串是否跟给定的正则表达式匹配 常用特殊字符及含义 . 匹配除了换行的任意字符 如果指定了标签 DOTALL (re.S, re.DOTALL)，它将匹配包括换行符的任意字符 ^ 匹配字符串的开头 $ 匹配字符串尾或者换行符的前一个字符 * 对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串 + 对它前面的正则式匹配1到任意次重复 ? 对它前面的正则式匹配0到1次重复 *?, +?, ?? '*', '+'和 '?' 修饰符都是贪婪的, 它们在字符串进行尽可能多的匹配 在修饰符之后添加 ? 将使样式以 非贪婪 方式进行匹配 , 尽量少的字符将会被匹配 {m-n} 对其之前的正则式指定匹配 m-n个重复 ,在 m 和 n 之间取尽量多 {m-n}? 上一个修饰符的非贪婪模式，只匹配尽量少的字符次数 \\ 转义特殊字符 [] 用于表示一个字符集合 | A|B A 和 B 可以是任意正则表达式, 一旦 A 匹配成功， B 就不再进行匹配 b,B s,S d,D w,W Z... 等特殊转义字符详解见 re正则表达式操作 模块 re.compile(pattern, flags=0) 将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 通过 re.compile()编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题. import re a = '''aaa\\nbbbb''' tmp = re.compile(r'(.*)\\n(.*)') tmp.match(a) ## ## 等价于 re.match(pattern=r'(.*)\\n(.*)', string=a, flags=0) flags: re.A(re.ASCII) 让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配ASCII，而不是Unicode re.DEBUG 显示编译时的debug信息 re.I(re.IGNORECASE) 进行忽略大小写匹配 re.S(re.DOTALL) 让 '.' 特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.' 就匹配除了换行符的其他任意字符 re.search(pattern, string, flags=0 ) 扫描整个字符串找到匹配样式的第一个位置, 并返回一个相应的匹配对象 如果没有匹配，就返回 None re.match(pattern, string, flags=0 ) 如果 string 开始的0或者多个字符匹配到了正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'.*b\\n') tmp.search(a) ## tmp.match(a) ## None re.fullmatch(pattern, string, flags=0 ) 如果整个 string 匹配到正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naaa\\naaa''' tmp = re.compile(r'.*\\n.*\\n.*') tmp.fullmatch(a) ## re.split(pattern, string, flags=0 ) 用 pattern 分开 string , 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里. 如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素 re.split(r'\\W+', 'Words, words, words.', 1) # ['Words', 'words, words.'] re.findall(pattern, string, flags=0 ) 对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回. 如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）. 空匹配也会包含在结果里. import re a = '''aaa\\naab\\naac\\n''' re.findall(r'.+\\n.*?',a) ## ['aaa\\n', 'aab\\n', 'aac\\n'] re.finditer(pattern, string, flags=0 ) pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 . string 从左到右扫描，匹配按顺序排列. 空匹配也包含在结果里. import re a = '''aaa\\naab\\naac\\n''' c = [] [c.append(i.group(0)) for i in re.finditer(r'.+[a|b]\\n.*?',a)] print(c) ## ['aaa\\n', 'aab\\n'] re.sub(pattern, repl, string, count=0, flags=0) 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串. 如果样式没有找到，则不加改变地返回 string. repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理. 如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用. 这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串. re.subn(pattern, repl, string, count=0, flags=0) 行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数). 正则表达式对象 编译后的正则表达式对象支持的方法和属性 pattern = re.compile(\"\\n\") Pattern.search(string[, pos[, endpos]]) Pattern.match(string[, pos[, endpos]]) Pattern.fullmatch(string[, pos[, endpos]]) Pattern.split(string[, pos[, endpos]]) Pattern.findall(string[, pos[, endpos]]) Pattern.finditer(string[, pos[, endpos]]) Pattern.sub(string[, pos[, endpos]]) Pattern.subn(string[, pos[, endpos]]) Pattern.flags 正则匹配标记 Pattern.groups 捕获组合的数量 Pattern.groupindex 映射由 (?P) 定义的命名符号组合和数字组合的字典 如果没有符号组, 那字典就是空的 Pattern.pattern 编译对象的原始样式字符串 匹配对象 匹配对象总是有一个布尔值 True. 如果没有匹配的话 match() 和 search() 返回 None 所以可以用 if 语句来判断是否匹配 import re a = '''aaa\\naab\\naac\\n''' x = re.match(r'.+\\n.*?',a) if x: print(x.group()) ## aaa Match.group([group1, ...]) 返回一个或者多个匹配的子组. 如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项） 如果没有参数，组1默认到0（整个匹配都被返回） import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.group() ## 'aaa\\naab\\naaa' x.group(0) ## 'aaa\\n' x.group(1) ## 'aab\\n' Match.groups(default=None) 返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合. default 参数用于不参与匹配的情况，默认为 None. import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.groups() ## ('aaa\\n', 'aab\\n') Match.start([group]) Match.end([group]) 返回 group 匹配到的字串的开始和结束标号 x.start() ## 0 x.end () ## 11 Match.span([group]) 对于一个匹配 m, 返回一个二元组 (m.start(group), m.end(group)). 如果 group 没有在这个匹配中，就返回 (-1, -1). group 默认为0，就是整个匹配. x.span() ## (0, 11) x.span(1) ## (0, 4) x.span(2) ## (4, 8) Match.pos Match.endpos 正则引擎开始/停止在字符串搜索一个匹配的索引位置 Match.re 返回产生这个实例的 正则对象, 这个实例是由 正则对象的 match() 或 search() 方法产生的 Match.string 传递到 match() 或 search() 的字符串 "},"PythonShare/Numbers&Datatime.html":{"url":"PythonShare/Numbers&Datatime.html","title":"Numbers&Datatime","keywords":"","body":"Numbers&Datatime Numbers 数字的四舍五入 # 对于简单的舍入运算，使用内置的 round(value, ndigits) 函数 round(1.23, 1) round(1.27, 1) round(1.5,0) round(2.5,0) a = 1627731 round(a, -1) round(a, -2) # 简单的输出一定宽度的数,格式化的时候指定精度 x = 1.23456 format(x, '0.3f') print('value is {:0.3f}'.format(x)) 执行精确的浮点数运算 a = 4.2 b = 2.1 print(a + b==6.3) #底层 CPU 和 IEEE 754 标准通过自己的浮点单位去执行算术时导致 #decimal 模块更精确但损耗性能 from decimal import Decimal a = Decimal('4.2') b = Decimal('2.1') print(type(a + b)) Decimal('6.3')==a+b nums = [1.23e+18, 1, -1.23e+18] sum(nums) import math math.fsum(nums) 数字的格式化输出 x = 1234.56789 format(x, '0.2f') format(x, '>10.1f') format(x, ' 二八十六进制整数 # 为了将整数转换为二进制、八进制或十六进制的文本串，可以分别使用 bin(),oct() 或 hex() 函数： x = 1234 bin(x) oct(x) hex(x) # 不想输出 0b , 0o 或者 0x 的前缀的话，可以使用 format() 函数 format(x, 'b') format(x, 'o') format(x, 'x') # 不同的进制转换整数字符串，简单的使用带有进制的 int() 函数 int('4d2', 16) int('10011010010', 2) 字节到大整数的打包与解包 data = b'\\x00\\x124V\\x00x\\x90\\xab\\x00\\xcd\\xef\\x01\\x00#\\x004' ##字节字符串 #int.from_bytes(bytes, byteorder, *, signed=False) #参数解释： bytes是要转换的十六进制； #byteorder：选'big'和'little'，以上例为例，其中big代表正常顺序，即f1ff。little反之，代表反序fff1； #signed：选True、Flase表示是否要区分二进制的正负数含义。即是否要对原二进制数进行原码反码 补码操作。 int.from_bytes(data, 'little') int.from_bytes(data, 'big') x = 94522842520747284487117727783387188 x.to_bytes(16, 'big') x.to_bytes(16, 'little') x = 0x01020304 x.to_bytes(4, 'big') x.to_bytes(4, 'little') 复数的数学运算 j*2=-1 a = complex(2, 4) b = 3 - 5j a.real a.imag a.conjugate() ###共轭复数 两个实部相等，虚部互为相反数的复数互为共轭复数 a + b a * b a / b abs(a) import cmath cmath.sin(a) cmath.cos(a) cmath.exp(a) #Python 的标准数学函数确实情况下并不能产生复数值 math.sqrt(-1) cmath.sqrt(-1) 无穷大与 NaN #创建 a = float('inf') b = float('-inf') c = float('nan') d = float('nan') math.isinf(a) math.isnan(c) a + 45 a * 10 10 / a a/a a + b c + 23 c / 2 math.sqrt(c) print(c==d) 3.8,3.9,3.10 分数运算，大型数组运算，矩阵和线性代数运算 大家自己看看 随机选择 import random values = [1, 2, 3, 4, 5, 6] random.choice(values) ###一个元素 random.choice(values) random.sample(values, 2) ##多个元素 random.shuffle(values) ##打乱顺序 #生成随机整数 random.randint(0,10) #生成 0 到 1 范围内均匀分布的浮点数 random.random() #获取 N 位随机位 (二进制) 的整数 random.getrandbits(10) ###随机种子 random.seed(12345) Datatime 基本的日期与时间转换 from datetime import timedelta a = timedelta(days=2, hours=6) b = timedelta(hours=4.5) c = a + b c.days c.seconds c.seconds / 3600 c.total_seconds() / 3600 from datetime import datetime a = datetime(2012, 9, 23) print(a + timedelta(days=10)) #days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0 b = datetime(2012, 12, 21) d = b - a d d.days now = datetime.today() print(now) print(now + timedelta(minutes=10)) from dateutil.relativedelta import relativedelta a + relativedelta(months=+1) d = relativedelta(b, a) 计算最后一个周五的日期 from datetime import datetime from dateutil.relativedelta import relativedelta from dateutil.rrule import * print(d + relativedelta(weekday=FR(3))) "}}