{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is for advanced data analysts ... "},"Databases/":{"url":"Databases/","title":"Databases","keywords":"","body":"Introduction mysql hive presto mongodb redis "},"Databases/Presto/":{"url":"Databases/Presto/","title":"Presto","keywords":"","body":"Presto 介绍了常用的Presto函数 "},"Databases/Presto/Presto简介&时间函数.html":{"url":"Databases/Presto/Presto简介&时间函数.html","title":"Presto简介&时间函数","keywords":"","body":"Presto简介 Presto是什么 Presto是由Facebook开发的分布式SQL 查询引擎，用来进行高速、实时的数据分析 Presto的产生是为了解决Hive的MapReduce模型太慢的问题 Presto是一个计算引擎，它不存储数据，通过丰富的Connector获取第三方的数据，并支持扩展 注意点：查询引擎，非数据库，不存储数据,获取第三方的数据 hive :（基于Hadoop的数据仓库工具）提供存储、查询 Presto优点 支持标准SQL，降低使用门槛 可以连接多种数据源，包括Hive、RDBMS（Mysql、Oracle、Tidb等）、Kafka、MongoDB、Redis等 一个低延迟高并发的内存计算引擎，相比Hive，执行效率要高很多 注意点：连接多种数据源，内存计算 Presto模型 查询示例：select \\ from hive.table1 a left join hive.table2 b on a.id = b.id* Catalog:就是数据源。Hive，Mysql是数据源，Hive 和Mysql都是数据源类型，可以连接多个Hive和多个Mysql。 Schema：相当于一个数据库实例，一个Schema包含多张数据表。 Table：数据表，与一般意义上的数据库表相同。 Presto日期时间函数 时区转换 格式: SELECT timestamp '2019-08-01 01:00 UTC' AT TIME ZONE 'America/Los_Angeles' UTC:格林威治时间/称世界统一时间、世界标准时间 比北京时间慢8个小时 ​ 示例:SELECT now() AT TIME ZONE 'America/Los_Angeles -- 比北京慢15小时北京时间 当前日期时间 函数 now()/ current_timestamp 返回timestamp with time zone** current_date：返回当前日期，只包含年月日 current_time: 返回time with time zone 示例:SELECT NOW() \"now\", current_timestamp \"current_timestamp\" , current_date \"current_date\", current_time \"current_time\" 注意: mysql:now()/sysdate(),curtime(),curdate() presto sql:current_date,current_time,current_timestamp函数都没有括号 时间格式转换 函数:cast(value AS type) → type 显式把value转换到type类型。 Presto SQL大的“特点”：完全不同的数据类型之间不能比较，相似的数据类型一般可以比较。 date与varchar完全不同,不可以比较 cast('2019-08-01' as date),date('2019-08-01' ) cast('2019-08-01 16:00:00.000' as TIMESTAMP) cast('2019-08-01 16:00:00.000' as date) 报错 需要截取 注意:长转短需要截取,短转长会自动补齐 示例:select current_date > cast('2019-07-31' as date) ; ​ select current_date > date'2019-07-31' ; ​ select '2019-08-01' > '2019-07-31' ; ​ select substr(lp.adjust_start_time,1,10) ,lp.adjust_start_time ​ from table lp ​ where substr(lp.time,1,10) = '2019-08-01' limit 1; 截取函数 ​ date_trunc(unit, x) 返回x截取到单位unit之后的值 函数 支持如下单位： 单位 Example Truncated Value second 2001-08-22 03:04:05.000 minute 2001-08-22 03:04:00.000 hour 2001-08-22 03:00:00.000 day 2001-08-22 00:00:00.000 week 2001-08-20 00:00:00.000 month 2001-08-01 00:00:00.000 quarter 2001-07-01 00:00:00.000 year 2001-01-01 00:00:00.000 示例:select date_trunc('hour',current_timestamp); ​ select date_trunc('week',current_timestamp); ​ select date_trunc('month',current_timestamp); ​ select date_trunc('quarter',current_timestamp); 间隔函数 date_add(unit, value, timestamp)→ [same as input] 在timestamp的基础上加上value个unit。如果想要执行相减的操作，可以通过将value赋值为负数来完成。 函数支持如下所列的间隔单位： Unit Description second Seconds minute Minutes hour Hours day Days week Weeks month Months quarter Quarters of a year year Years 示例: select date_add('day',1,now()); ​ select date_add('hour',-1,now()); ​ select date_add('quarter',1,now()); -- 增加一个季度即增加三个月 时间差函数 date_diff(unit, timestamp1, timestamp2) 返回 (timestamp2 - timestamp1) 之后的值，该值的表示单位是unit. 注意:unit加引号 ,mysql 中 DATEDIFF(date1,date2) 是date1-date2 示例: select date_diff('hour', TIMESTAMP'2018-08-08 08:08:08', TIMESTAMP'2018-08-08 00:00:00') ; ​ select date_diff('quarter', TIMESTAMP'2019-08-08 08:08:08', TIMESTAMP'2019-12-02 06:00:00.000') ; 日期格式化函数 date_format(timestamp, format) → varchar 使用format指定的格式，将timestamp格式化成字符串 支持类型单位 注意:%D %U %u %V %X %w 暂不支持* 分类符 说明 %a Abbreviated weekday name (Sun .. Sat) %b Abbreviated month name (Jan .. Dec) %c Month, numeric (0 .. 12) %D Day of the month with English suffix (0th, 1st, 2nd, 3rd, …) %d Day of the month, numeric (00 .. 31) %e Day of the month, numeric (0 .. 31) %f Fraction of second (6 digits for printing: 000000 .. 999000; 1 - 9 digits for parsing: 0 .. 999999999) %H Hour (00 .. 23) %h Hour (01 .. 12) %I Hour (01 .. 12) %i Minutes, numeric (00 .. 59) %j Day of year (001 .. 366) %k Hour (0 .. 23) %l Hour (1 .. 12) %M Month name (January .. December) %m Month, numeric (00 .. 12) %p AM or PM %r Time, 12-hour (hh:mm:ss followed by AM or PM) %S Seconds (00 .. 59) %s Seconds (00 .. 59) %T Time, 24-hour (hh:mm:ss) %U Week (00 .. 53), where Sunday is the first day of the week %u Week (00 .. 53), where Monday is the first day of the week %V Week (01 .. 53), where Sunday is the first day of the week; used with %X %v Week (01 .. 53), where Monday is the first day of the week; used with %x %W Weekday name (Sunday .. Saturday) %w Day of the week (0 .. 6), where Sunday is the first day of the week %X Year for the week where Sunday is the first day of the week, numeric, four digits; used with %V %x Year for the week, where Monday is the first day of the week, numeric, four digits; used with %v %Y Year, numeric, four digits %y Year, numeric (two digits) %% A literal % character %x x, for any x not listed above 示例:SELECT date_format(current_timestamp,'%Y-%m-%d %W %H:%i:%s') date_parse(string, format) → timestamp 按照format指定的格式，将字符串string解析成timestamp 注意:两边形式要一样 date_parse('2019-08-01 ','%Y-%m-%d %H:%i:%s') 会报错 示例: SELECT date_parse('2019-08-01 08:08:08','%Y-%m-%d %H:%i:%s'); 抽取函数 extract(field FROM x)→ bigint(整数) 从x中返回域field 抽取函数支持的数据类型取决于需要抽取的域。大多数域都支持日期和时间类型。 可以使用抽取函数来抽取如下域： Field Description YEAR year() QUARTER quarter() MONTH month() WEEK week() DAY day() DAY_OF_MONTH day() DAY_OF_WEEK day_of_week() DOW day_of_week() DAY_OF_YEAR day_of_year() DOY day_of_year() YEAR_OF_WEEK year_of_week() YOW year_of_week() HOUR hour() MINUTE minute() SECOND second() TIMEZONE_HOUR timezone_hour() :表示时区偏移小时量 TIMEZONE_MINUTE timezone_minute() 示例: select extract(year FROM current_timestamp) ,extract(month from DATE'2019-08-01'),extract(DAY FROM now()), extract(WEEK from now()),extract(doy FROM now()); ​ select extract(TIMEZONE_HOUR FROM now()) \"时区偏移小时量\"; 便利的抽取函数: 格式 day(x) → bigint 返回指定日期在当月的天数 day_of_month(x) → bigint day(x)的另一种表述 day_of_week(x) → bigint 返回指定日期对应的星期值，值范围从1 (星期一) 到 7 (星期天). day_of_year(x) → bigint 返回指定日期对应一年中的第几天，值范围从1到 366. dow(x) → bigint day_of_week()的另一种表达 doy(x) → bigint day_of_year()的另一种表达 hour(x) → bigint 返回指定日期对应的小时，值范围从1到 23 minute(x) → bigint 返回指定日期对应的分钟 month(x) → bigint 返回指定日期对应的月份 quarter(x) → bigint 返回指定日期对应的季度，值范围从1到 4 second(x) → bigint 返回指定日期对应的秒 timezone_hour(timestamp) → bigint 返回从指定时间戳对应时区偏移的小时数 timezone_minute(timestamp) → bigint 返回从指定时间戳对应时区偏移的分钟数 week(x) → bigint 返回指定日期对应一年中的ISO week，值范围从1到 53 week_of_year(x) → bigint week的另一种表述 year(x) → bigint 返回指定日期对应的年份 year_of_week(x) → bigint 返回指定日期对应的ISO week的年份 yow(x) → bigint year_of_week()的另一种表达 示例:select year(now()) ,month(now()),day(now()),doy(now()),quarter(now()),week(now()); 补充: sum() over() sum() over(PARTITION BY columnA order by columnB ) :类似于Python中 cumsum(),实现累计和功能 官方文档 http://prestodb.jd.com/docs/current/index.html* "},"Databases/Presto/Presto常用函数.html":{"url":"Databases/Presto/Presto常用函数.html","title":"Presto常用函数","keywords":"","body":"1.字符串长度计算函数：length 语法: length(string A) select length('iteblog') 2.字符串反转函数：reverse 语法: reverse(string A) 返回值: string 说明：返回字符串A的反转结果 select reverse('iteblog') 3.字符串连接函数：concat 语法: concat(string A, string B…) 返回值: string 说明：返回输入字符串连接后的结果，支持任意个输入字符串 select concat('www','iteblog','com') 使用||运算符实现字符串的拼接(快) select 'www' || 'iteblog' || 'com' 4.字符串截取函数：substr,substring 语法: substr(string A, int start),substring(string A, int start) 返回值: string 说明：返回字符串A从start位置到结尾的字符串 select substr('iteblog',3) select substr('iteblog',3,2) select substr('iteblog',-3,2) select substring('iteblog',3) select substring('iteblog',3,2) select substring('iteblog',-3,2) 5.replace(string, search) → varchar 删除字符串 string 中的所有子串 search 。 select replace('itebtlog', 't') replace(string, search, replace) → varchar 将字符串 string 中所有子串 search 替换为 replace。 select replace('itebtlog', 't','k') 6.strpos(string, substring) → bigint 返回字符串中子字符串的第一次出现的起始位置。位置以 1 开始 ，如果未找到则返回 0 。 select strpos('titebtlog', 't') select strpos('itebtlog', 'p') 7.regexp_replace:将原字符中的指定字符替换 select regexp_replace('aabb','b','c') 8.regexp_extract：通过下标返回正则表达式指定的部分 select regexp_extract('123abc456','([0-9]*)([a-z]*)([0-9]*)',3) 9.coalesce:返回参数列表中第一个非null值(非空值) select coalesce(null,'a','b') select coalesce(null,null,null) 将null值替换 select student_intention_id, student_no, name, coalesce(name,'小花') from view_student where name is null limit 10 10.条件函数:if select if(1+1=2,'a','b') 11.窗口函数 first_value(x):返回窗口内的第一个value，一般用法是窗口内数值排序，获取最大值。 last_value(x) 含义和first value相反。 sum() select lp.student_id, cast(substr(lp.adjust_start_time,1,19) as timestamp) adjust, teacher_id, first_value(teacher_id) OVER (PARTITION BY student_id ORDER BY cast(substr(lp.adjust_start_time,1,19) as timestamp) ), first_value(lp.adjust_start_time) OVER (PARTITION BY student_id ORDER BY cast(substr(lp.adjust_start_time,1,19) as timestamp) ) from lesson_plan lp where student_id in (1537357,1537006,1537362,1537336,1537025) 12.数组函数 array_agg (key)是一个聚合函数，表示把key这一列的所有内容变成一个数组返回。 array_distinct：返回去重后的数组 array_max(array) -> E 返回数组中最大的元素 array_min(array) -> E 返回数组中最小的元素 array_position(x, element) -> bigint 返回element在数组中的位置 contains(x, element) -> boolean 判断element是否在数组x中 array_remove(x, element) -> x 移除数组x中的所有element元素 cardinality(x) -> bigint 返回数组的元素个数 select lp.student_id, -- array_agg(sj.subject_name), -- array_agg(distinct sj.subject_name), -- array_distinct(array_agg(subject_name)) -- array_agg(distinct sj.subject_id), -- array_max(array_agg(distinct sj.subject_id)) -- array_position(array_agg(distinct sj.subject_name),'体验课'), -- contains(array_agg(distinct sj.subject_name),'体验课'), -- array_remove(array_agg(distinct sj.subject_name),'体验课') -- cardinality(array_agg(distinct sj.subject_name)) --array_join(array_agg(distinct subject_name), '-') subject_name from lesson_plan lp left join subject sj on sj.subject_id = lp.subject_id where student_id in (1537357,1537006,1537362,1537336,1537025) group by lp.student_id 13.lambda函数 lambda表达式的书写形式为-> (1)filter(array, function) -> array array中的每一个元素经过function过滤，返回都为true的元素 (2)transform(array, function) → ARRAY 对数组中的每个元素，依次调用function，生成新的结果U。 select lp.student_id, array_agg(distinct lp.lesson_type), filter(array_agg(distinct lp.lesson_type), x -> x=3), array_agg(distinct subject_name), transform(array_agg(distinct subject_name), x -> substr(x,1,2)) from lesson_plan lp left join subject sj on sj.subject_id = lp.subject_id where student_id in (1537357,1537006,1537362,1537336,1537025) group by lp.student_id "},"Databases/Presto/Presto数组&字符串函数.html":{"url":"Databases/Presto/Presto数组&字符串函数.html","title":"Presto数组&字符串函数","keywords":"","body":"数组函数 element_at(array,index) 返回数组中索引index对应的元素(index可以为负数) array_position(array, element) 返回element在数组中的位置(bigint) array_agg() 聚合函数，将一列所有内容变成一个数组返回。 array_join(array,delimiter,null_value_replacement) 将数组中的所有元素以delimiter指定的分隔符连接起来，null值用null_value_replacement代替，返回一个字符串 filter(array,function) 将函数function中返回true的元素来构造新数组 SELECT filter(ARRAY [], x -> true); -- [] SELECT filter(ARRAY [5, -6, NULL, 7], x -> x > 0); -- [5, 7] SELECT filter(ARRAY [5, NULL, 7, NULL], x -> x IS NOT NULL); -- [5, 7] 字符串函数 split(string，delimiter) 以delimiter分隔符拆分字符串,返回一个数组。 split_part （string，delimiter，index） 以delimiter分隔符拆分字符串,返回索引对应的字符串.字段索引以1开头(不可为负数).如果索引大于字段数，则返回null. 类似于mysql中substring_index函数(index>0). select split_part('北京,上海,广州',',',1) -- 北京 strpos(string，substring) 返回子字符串在字符串中第一次出现的位置。从1开始。如果未找到，则返回0。 类似于mysql中的locate函数,但locate是子字符串在前. select strpos('上海销售分公司四中心二区二部精英学院','精英学院') -- 15 substr(string,start) 从start位置开始返回字符串的其余部分。位置从1开始。如果start为负，则起始位置代表从字符串的末尾开始倒数 select substr('数学,英语,', -1) -- , select substr('数学,英语,', -1) -- 英语, substr(string, start, length) 从start位置开始返回长度为length的字符串的子串。位置从1开始。如果start为负，则起始位置代表从字符串的末尾开始倒数 组合使用 array_join(array_agg(),delimiter,null_value_replacement) 类似于mysql中的group_concat函数. select tcp.contract_id,array_join(array_agg(pay_method_new),',') from table1 tcp left join table2 tc on tc.contract_id = tcp.contract_id where tcp.contract_id = 'X20011907000631' and tcp.pay_status in (2,4) and tc.status not in (7,8) group by tcp.contract_id array_join(filter(array_agg(conditon),function),delimiter) select array_join(filter( array_agg(case when is_success_extend = 0 then tbk.extend_subject_name else null end),x -> x is not null ),',') 当需要加判断条件时,如果不加filter函数,用以下写法,字段最后可能会出现逗号 select array_join( array_agg(case when is_success_extend = 0 then tbk.extend_subject_name end), ',') extend_fail_subject_name element_at(split(string,delimiter),index) 类似于mysql中的substring_index函数. select element_at(split('北京,上海,广州',','),-1) -- 广州 select element_at(split('北京,上海,广州',','),2) -- 上海 select element_at(split('客户关系部,课程顾问部,江苏分公司,江苏销售一中心,江苏销售一中心一区,江苏销售一中心一区二部',','),-1) 去掉字符串末尾的逗号 select (case when substr('数学,英语,', -1) = ',' then substr('数学,英语,',1,length('数学,英语,')-1) end) -- 数学,英语 "},"DataAnalystHelper/":{"url":"DataAnalystHelper/","title":"DataAnalystHelper","keywords":"","body":"Introduction 本项目从BI层面提供数据服务支持方面, 封装了常用方法 使数据分析师在日常工作中快速搭建数据服务来专注业务逻辑 代码主要对以下几大点做封装 数据库连接查询(Mysql , Hive) 数据表生成(Mysql中间表) DataFrame常用方法二次封装(时间函数, 输出Excel, merge...) 输出内容相关(html模板渲染, 钉钉自定义机器人) ...... 具体代码请前往 https://github.com/advanceddataanalysts/AdvancedPython "},"PythonShare/":{"url":"PythonShare/","title":"PythonShare","keywords":"","body":"PythonShare "},"PythonShare/PythonTips/":{"url":"PythonShare/PythonTips/","title":"PythonTips","keywords":"","body":"PythonTips "},"PythonShare/PythonTips/动态执行代码.html":{"url":"PythonShare/PythonTips/动态执行代码.html","title":"动态执行代码","keywords":"","body":"Python动态导入模块&动态执行Python代码 1. 动态导入模块方法: ## 栗子:在lib下定义模块along_pack class FirstImport(object): def __init__(self, name=\"along\"): self.name = name def start(self): return \"你好呀 !\" + self.name 直接使用__import__模块 lib = __import__('lib.along_pack') c = lib.along_pack.FirstImport() print(c.start()) ## 你好呀 !along 使用import importlib里的 importlib.import_module方法 import importlib a = importlib.import_module('lib.along_pack') c = a.FirstImport(name='strong') print(c.start()) ## 你好呀 !strong getattr(obj,name,val):返回对象obj中名为name的属性值，如果没有该属性，且给定了val参数，则返回val hasattr(obj,name):如果对象obj中存在名为name的属性，则返回True delattr(obj,name):删除obj中名为name的属性 setattr(obj,name,val):将对象obj中名为name的属性值设置为val，如果不存在该属性，则进行创建 两种方法的区别: 方法2 代码更简洁,并且支持reload( ) 1 reload()重新加载，一般用于原模块有变化等特殊情况。 2 reload()之前该模块必须已经使用import导入模块。 3 重新加载模块，但原来已经使用的实例还是会使用旧的模块，而新生产的实例会使用新的模块，reload后还是用原来的内存地址。 2. 动态执行python代码 exec : 把传入的字符串当代码执行,不返回结果 a = 1 exec (\"a=2\") ##无结果输出 print(a) ## 2 b = \"pandas\" print(exec(\"import %s as pd\"%b)) ##None pd.read_excel(r'E:\\Desktop\\along_test\\along_hetong_test.xlsx') eval : 把传入的字串串当成表达式执行,返回结果 a = [1,2] b = ['along','strong'] a_dic = dict(zip(a,b)) print(a_dic) ## {1: 'along', 2: 'strong'} cc = \"a_dic[3] ='lp'\" eval(cc) ##报错 exec(cc) ##print(a_dict) {1: 'along', 2: 'strong', 3: 'lp'} ##两个都可以解析字符串中的字符当成关键字参数进行运算 dd = 'a+b' print(dd) ## 'a+b' eval(dd) ##[1, 2, 'along', 'strong'] exec(dd) ##print(dd) 'a+b' "},"PythonShare/PythonTips/正则替换非法字符.html":{"url":"PythonShare/PythonTips/正则替换非法字符.html","title":"正则替换非法字符","keywords":"","body":"正则替换非法字符 背景 : 在沟通相关的数据中, 比如沟通内容,这些字段为销售或班主任手动输入填写, 有时候会有一些特殊字符,比如 ︶︹︺ 解决方案 : 在window下一般使用GB18030编码也能解决, 但是部署到线上使用Linux执行脚本的时候会出现导出数据编码失败的问题 报错为 IllegalCharacterError() 普通的特殊字符直接按照一下处理 就可以把这些字符转换为空 x = '特殊字符巴拉巴拉' ILLEGAL_CHARACTERS_RE = re.compile(r'[\\000-\\010]|[\\013-\\014]|[\\016-\\037]') x = ILLEGAL_CHARACTERS_RE.sub(r'', x) 但是总有些你不知道的什么鬼符号出现,就连上面的编码都找不到,这个时候就要把这条记录找到然后把它的编码转化成' ' 做法非常暴力: ## 我得到的数据为df, 有问题的那一列为 df['最后沟通内容'] ## 因为是转换成excel那一步的时候出了问题, 所以就在那里打印检查 for i in range(df.shape[0]): if i "},"PythonShare/Dictionary.html":{"url":"PythonShare/Dictionary.html","title":"Dictionary","keywords":"","body":"Dictionary Q 构建字典时 创建字典引用其他字典时,不知道key是否存在,如果key存在则去重 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: dic = {} def add_dic(pairs,dic): for key,value in pairs.items(): if key not in dic: dic[key] = [] dic[key].append(value) dic[key] = list(set(dic[key])) return dic add_dic(pairs=pairs,dic=dic) add_dic(pairs=pairs1,dic=dic) ## 方法二: ## 代码结构更清晰 from collections import defaultdict s_dict = defaultdict(set) def s_add_dic(pairs,dic): for key,value in pairs.items(): s_dict[key].add(value) return dic s_add_dic(pairs=pairs,dic=s_dict) s_add_dic(pairs=pairs1,dic=s_dict) Q 构建字典时 保证字典有序 ## 方法一: ## python3.6之后字典会按照构建顺序自动排序 dic = {} dic['a'] = 1 dic['b'] = 2 dic['c'] = 3 dic['d'] = 4 print(dic) ## {'a': 1, 'c': 3, 'b': 2, 'd': 4} ## 方法二: ## 必按照添加顺序排序 w+s ## OrderedDict内部维护了双向链表,根据加入顺序排列键的位置,但是大小是普通字典的2倍大 from collections import OrderedDict s_dic = OrderedDict() s_dic['a'] = 1 s_dic['b'] = 2 s_dic['c'] = 3 s_dic['d'] = 4 print(dict(s_dic)) ## {'a': 1, 'b': 2, 'c': 3, 'd': 4} Q 构建字典时 从已有的字典中提取子集 ## 字典推导式 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} dic = {key:value for key,value in pairs.items() if key in ['apple','orange']} print(dic) Q 构建字典时 字典映射 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: ## 构建新的字典对象/在原始字典上修改 new_pairs = dict(pairs1) new_pairs.update(pairs) print(new_pairs) ## 方法二: ## ChainMap使用原始字典映射,更改原始字典同步反应到映射对象上 from collections import ChainMap cm_pairs = ChainMap(pairs,pairs1) print({key:value for key,value in cm_pairs.items()}) ## 对ChaipMap对象的修改只会反映到第一个dict对象上, 反之亦然, 对字典的修改只有第一个的修改会反映到ChaipMap对象上 cm_pairs['tuberose'] = 99999999999999999999 print(cm_pairs,'\\n',pairs,'\\n',pairs1) pairs1['tuberose'] = 9999999888888888999999999999 print({key:value for key,value in cm_pairs.items()}) Q 对字典进行计算 将字典的key替换, value不变 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} ## 方法一: pairs['new_apple'] = pairs.pop('apple') ## 方法二: pairs.update({'new_apple':pairs.pop(\"apple\")}) Q 对字典进行计算 求value最值对应的key:value对 prices = {'A':2.22,'B':9.06,'C':0.06,'D':9.06,'E':0.06} print(max(prices)) ## 'E' ## 多条记录value相等时 按照第二个参数大小排序 print(max(zip(prices.values(),prices.keys()))) ## (9.06, 'D') ## 多条记录value相等时 取第一次出现的键值对 print(max(prices, key=lambda k: prices[k]), prices[max(prices, key=lambda k: prices[k])]) ## B 9.06 Q 对字典进行计算 求两个/多个字典的相同点 a_dict = {'x':1, 'y':2, 'z':3} b_dict = {'x':1, 'y':2, 'w':3} c_dict = {'x':1} print(a_dict.keys() & b_dict.keys()) ##{'x', 'y'} print(a_dict.keys() & b_dict.keys() & c_dict.keys()) ##{'x'} print(a_dict.items() & b_dict.items()) ## {('x', 1), ('y', 2)} c = {key:a_dict[key] for key in a_dict.keys() - {'z','w'}} print(c) ##{'x': 1, 'y': 2} Q 对字典进行计算 通过公共键对字典列表排序 rows = [{'fname':11, 'lname':2, 'uid':1003}, {'fname':111, 'lname':22, 'uid':1004}, {'fname':111, 'lname':222, 'uid':1002}, {'fname':11, 'lname':222, 'uid':1003},] ## 方法一: sorted(rows, key=lambda x:x['uid']) sorted(rows, key=lambda x:(x['fname'],x['lname'])) ## 方法二: ## 运行速度更快,性能好(max,min也同样支持) from operator import itemgetter sorted(rows, key=itemgetter('uid'), reverse=True) sorted(rows, key=itemgetter('fname','lname'),reverse=False) ## 方法三: ## 抓成df,排序结束再用df.to_dict()/df.to_json()转 import pandas as pd data = pd.DataFrame(rows) data.sort_values(by=['uid'],inplace=True) data.to_dict(orient='records') Q 对字典进行计算 根据键对数据进行分组 rows = [{'address':'zhongguancun', 'date':'07/01/2018'}, {'address':'putuo', 'date':'07/02/2018'}, {'address':'wangfujing', 'date':'07/01/2018'}, {'address':'jingan', 'date':'07/04/2018'},] ## 方法一: ## sort+itemgetter+groupby from operator import itemgetter from itertools import groupby rows.sort(key=itemgetter('date')) ##分组前需要先排序,因为groupby()只能检查连续的项 for key, value in groupby(rows, key=itemgetter('date')): print(key) for i in value: print(' ',i) ## 方法二: ## 转成df,groupby之后再转成字典 import pandas as pd data = pd.DataFrame(rows) for key,value in data.groupby(by=['date']): print(key,list(value.T.to_dict().values())) "},"PythonShare/DataStructure.html":{"url":"PythonShare/DataStructure.html","title":"DataStructure","keywords":"","body":"DataStructure * 解压 解压序列赋值给多个变量(作用可迭代对象) p = (4, 5) x, y = p data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] name, shares, price, date = data name, shares, price, (year, mon, day) = data s = 'Hello' a, b, c, d, e = s # 变量个数和序列元素的个数不匹配，会产生一个异常 p = (4, 5) x, y, z = p # 部分解压 data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] _, shares, price, _=data 解压可迭代对象赋值给多个变量 record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212') record = ('Dave', 'dave@example.com') record = ('Dave', 'dave@example.com','773-555-1212', '847-555-1212','773-555-1213', '847-555-1213') name, email, *phone_numbers = record phone_numbers #星号表达式也能用在列表的开始部分 *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current trailing, *current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false' uname, *fields, homedir, sh = line.split(':') 双向队列 deque:double-ended queue #双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。 #将队列的两端分别称为前端和后端，两端都可以入队和出队 栈:栈是一种后进先出的数据结构，我们可以借助list来实现栈 stack = [] stack.append(item1) # 入栈 stack.pop() # 出栈，返回结果是出栈元素 peak = stack[-1] # 返回栈顶元素 队列:队列是一种先进先出的数据结构，我们可以借助list来实现队列 queue = [] queue.append(item) # 入队 queue.pop(0) # 出队，返回结果是出队元素 在队列两端插入或删除元素时间复杂度都是 O(1) ， 而在列表的开头插入或删除元素的时间复杂度为 O(N) 。 from collections import deque q = deque(maxlen=3) q.append(1) q.append(2) q.append(3) q.append(4) q.append(5) #q.appendleft(6) ###默认从右边 q.clear() #清空队列 q.count(n) #在队列中统计元素的个数，n表示统计的元素 q.extend(n) #从右边扩展队列，n表示扩展的队列 q.extendleft(n) #从左边扩展队列，n表示扩展的队列 q.pop() #队尾元素删去 q.popleft() #队头元素删去 Heap & Heapq 查找最大或最小的 N 个元素 堆： 1.建立在完全二叉树的基础上(若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数， 第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。) 2.排序算法的一种，也是稳定效率最高的一种 3.可用于实现STL中的优先队列(priority_queue) STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。 它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的 **优先队列**：一种特殊的队列，队列中元素出栈的顺序是按照元素的优先权大小，而不是元素入队的先后顺序 4.两类： a.最大堆： ①根的值大于左右子树的值 ②子树也是最大堆 b.最小堆： ①根的值小于左右子树的值 ②子树也是最小堆 该模块提供了堆排序算法的实现,heapq有两种方式创建堆， 一种是使用一个空列表， 然后使用heapq.heappush()函数把值加入堆中，另外一种就是使用heap.heapify(list)转换列表成为堆结构 ##插入 import heapq #载入heap库，heap指的是最小堆 nums = [2, 3, 5, 1, 54, 23, 132] heap = [] for num in nums: heapq.heappush(heap, num) # 加入堆 print(heap[0]) # 如果只是想获取最小值而不是弹出，使用heap[0] print([heapq.heappop(heap) for _ in range(len(nums))]) # 堆排序结果 heap= [] nums = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(nums) print(nums) print([heapq.heappop(heap) for _ in range(len(nums))]) import math from io import StringIO def show_tree(tree, total_width=36, fill=' '): \"\"\"Pretty-print a tree.\"\"\" output = StringIO() last_row = -1 for i, n in enumerate(tree): if i: row = int(math.floor(math.log(i + 1, 2))) else: row = 0 if row != last_row: output.write('\\n') columns = 2 ** row col_width = int(math.floor(total_width / columns)) output.write(str(n).center(col_width, fill)) last_row = row print(output.getvalue()) print('-' * total_width) print() data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) ##删除 #heapq.heappop() data = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(data) heap = [] while data: i=heapq.heappop(data) print('pop %3d:' % i) show_tree(data) heap.append(i) print(heap) import heapq nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] # print(heapq.nlargest(3, nums)) # Prints [42, 37, 23] # print(heapq.nsmallest(3, nums)) # portfolio = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price']) expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price']) ###最小堆转最大堆 只用对元素取负，按照最小堆的方式存储，取出来的值只要再取负，就是最大值了。即push(e)改为push(-e)，pop(e)为-pop(e) data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) heap1 = [] while heap: i=-1 * heapq.heappop(heap) print('pop %3d:' % i) show_tree(data) heap1.append(i) print(heap1) ####最大堆 实现一个优先级队列 import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] class Item: def __init__(self, name): self.name = name def __repr__(self): return 'Item({!r})'.format(self.name) q = PriorityQueue() q.push(Item('foo'), 1) q.push(Item('bar'), 5) q.push(Item('spam'), 4) q.push(Item('grok'), 1) q.pop() q.pop() q.pop() q.pop() "},"PythonShare/Regex.html":{"url":"PythonShare/Regex.html","title":"Regex","keywords":"","body":"Regex 模式匹配: 模式匹配是数据结构中字符串的一种基本运算, 给定一个子串, 要求在某个字符串中找出与该子串相同的所有子串 Tips: 正则表达式使用反斜杠（'\\'）来表示特殊形式，或者把特殊字符转义成普通字符. 而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突. 比如说，要匹配一个字面上的反斜杠，正则表达式模式不得不写成 '\\\\\\\\'，因为正则表达式里匹配一个反斜杠必须是 \\\\ ，而每个反斜杠在普通的 Python 字符串里都要写成 \\\\ . 解决办法是对于正则表达式样式使用 Python 的原始字符串表示法: 在带有 'r' 前缀的字符串字面值中，反斜杠不必做任何特殊处理. 因此 r\"\\n\" 表示包含 '\\' 和 'n' 两个字符的字符串，而 \"\\n\" 则表示只包含一个换行符的字符串. 样式在 Python 代码中通常都会使用这种原始字符串表示法来表示. import re ## 不带'r'前缀 a = '''aaa\\\\bbbb''' re.split('\\\\\\\\',a) # ['aaa', 'bbbb'] ## 带'r'前缀 re.split(r'\\\\',a) # ['aaa', 'bbbb'] 正则表达式语法 用来检查某个字符串是否跟给定的正则表达式匹配 常用特殊字符及含义 . 匹配除了换行的任意字符 如果指定了标签 DOTALL (re.S, re.DOTALL)，它将匹配包括换行符的任意字符 ^ 匹配字符串的开头 $ 匹配字符串尾或者换行符的前一个字符 * 对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串 + 对它前面的正则式匹配1到任意次重复 ? 对它前面的正则式匹配0到1次重复 *?, +?, ?? '*', '+'和 '?' 修饰符都是贪婪的, 它们在字符串进行尽可能多的匹配 在修饰符之后添加 ? 将使样式以 非贪婪 方式进行匹配 , 尽量少的字符将会被匹配 {m-n} 对其之前的正则式指定匹配 m-n个重复 ,在 m 和 n 之间取尽量多 {m-n}? 上一个修饰符的非贪婪模式，只匹配尽量少的字符次数 \\ 转义特殊字符 [] 用于表示一个字符集合 | A|B A 和 B 可以是任意正则表达式, 一旦 A 匹配成功， B 就不再进行匹配 b,B s,S d,D w,W Z... 等特殊转义字符详解见 re正则表达式操作 模块 re.compile(pattern, flags=0) 将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 通过 re.compile()编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题. import re a = '''aaa\\nbbbb''' tmp = re.compile(r'(.*)\\n(.*)') tmp.match(a) ## ## 等价于 re.match(pattern=r'(.*)\\n(.*)', string=a, flags=0) flags: re.A(re.ASCII) 让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配ASCII，而不是Unicode re.DEBUG 显示编译时的debug信息 re.I(re.IGNORECASE) 进行忽略大小写匹配 re.S(re.DOTALL) 让 '.' 特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.' 就匹配除了换行符的其他任意字符 re.search(pattern, string, flags=0 ) 扫描整个字符串找到匹配样式的第一个位置, 并返回一个相应的匹配对象 如果没有匹配，就返回 None re.match(pattern, string, flags=0 ) 如果 string 开始的0或者多个字符匹配到了正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'.*b\\n') tmp.search(a) ## tmp.match(a) ## None re.fullmatch(pattern, string, flags=0 ) 如果整个 string 匹配到正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naaa\\naaa''' tmp = re.compile(r'.*\\n.*\\n.*') tmp.fullmatch(a) ## re.split(pattern, string, flags=0 ) 用 pattern 分开 string , 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里. 如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素 re.split(r'\\W+', 'Words, words, words.', 1) # ['Words', 'words, words.'] re.findall(pattern, string, flags=0 ) 对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回. 如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）. 空匹配也会包含在结果里. import re a = '''aaa\\naab\\naac\\n''' re.findall(r'.+\\n.*?',a) ## ['aaa\\n', 'aab\\n', 'aac\\n'] re.finditer(pattern, string, flags=0 ) pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 . string 从左到右扫描，匹配按顺序排列. 空匹配也包含在结果里. import re a = '''aaa\\naab\\naac\\n''' c = [] [c.append(i.group(0)) for i in re.finditer(r'.+[a|b]\\n.*?',a)] print(c) ## ['aaa\\n', 'aab\\n'] re.sub(pattern, repl, string, count=0, flags=0) 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串. 如果样式没有找到，则不加改变地返回 string. repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理. 如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用. 这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串. re.subn(pattern, repl, string, count=0, flags=0) 行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数). 正则表达式对象 编译后的正则表达式对象支持的方法和属性 pattern = re.compile(\"\\n\") Pattern.search(string[, pos[, endpos]]) Pattern.match(string[, pos[, endpos]]) Pattern.fullmatch(string[, pos[, endpos]]) Pattern.split(string[, pos[, endpos]]) Pattern.findall(string[, pos[, endpos]]) Pattern.finditer(string[, pos[, endpos]]) Pattern.sub(string[, pos[, endpos]]) Pattern.subn(string[, pos[, endpos]]) Pattern.flags 正则匹配标记 Pattern.groups 捕获组合的数量 Pattern.groupindex 映射由 (?P) 定义的命名符号组合和数字组合的字典 如果没有符号组, 那字典就是空的 Pattern.pattern 编译对象的原始样式字符串 匹配对象 匹配对象总是有一个布尔值 True. 如果没有匹配的话 match() 和 search() 返回 None 所以可以用 if 语句来判断是否匹配 import re a = '''aaa\\naab\\naac\\n''' x = re.match(r'.+\\n.*?',a) if x: print(x.group()) ## aaa Match.group([group1, ...]) 返回一个或者多个匹配的子组. 如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项） 如果没有参数，组1默认到0（整个匹配都被返回） import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.group() ## 'aaa\\naab\\naaa' x.group(0) ## 'aaa\\n' x.group(1) ## 'aab\\n' Match.groups(default=None) 返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合. default 参数用于不参与匹配的情况，默认为 None. import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.groups() ## ('aaa\\n', 'aab\\n') Match.start([group]) Match.end([group]) 返回 group 匹配到的字串的开始和结束标号 x.start() ## 0 x.end () ## 11 Match.span([group]) 对于一个匹配 m, 返回一个二元组 (m.start(group), m.end(group)). 如果 group 没有在这个匹配中，就返回 (-1, -1). group 默认为0，就是整个匹配. x.span() ## (0, 11) x.span(1) ## (0, 4) x.span(2) ## (4, 8) Match.pos Match.endpos 正则引擎开始/停止在字符串搜索一个匹配的索引位置 Match.re 返回产生这个实例的 正则对象, 这个实例是由 正则对象的 match() 或 search() 方法产生的 Match.string 传递到 match() 或 search() 的字符串 "},"PythonShare/Numbers&Datatime.html":{"url":"PythonShare/Numbers&Datatime.html","title":"Numbers&Datatime","keywords":"","body":"Numbers&Datatime Numbers 数字的四舍五入 # 对于简单的舍入运算，使用内置的 round(value, ndigits) 函数 round(1.23, 1) round(1.27, 1) round(1.5,0) round(2.5,0) a = 1627731 round(a, -1) round(a, -2) # 简单的输出一定宽度的数,格式化的时候指定精度 x = 1.23456 format(x, '0.3f') print('value is {:0.3f}'.format(x)) 执行精确的浮点数运算 a = 4.2 b = 2.1 print(a + b==6.3) #底层 CPU 和 IEEE 754 标准通过自己的浮点单位去执行算术时导致 #decimal 模块更精确但损耗性能 from decimal import Decimal a = Decimal('4.2') b = Decimal('2.1') print(type(a + b)) Decimal('6.3')==a+b nums = [1.23e+18, 1, -1.23e+18] sum(nums) import math math.fsum(nums) 数字的格式化输出 x = 1234.56789 format(x, '0.2f') format(x, '>10.1f') format(x, ' 二八十六进制整数 # 为了将整数转换为二进制、八进制或十六进制的文本串，可以分别使用 bin(),oct() 或 hex() 函数： x = 1234 bin(x) oct(x) hex(x) # 不想输出 0b , 0o 或者 0x 的前缀的话，可以使用 format() 函数 format(x, 'b') format(x, 'o') format(x, 'x') # 不同的进制转换整数字符串，简单的使用带有进制的 int() 函数 int('4d2', 16) int('10011010010', 2) 字节到大整数的打包与解包 data = b'\\x00\\x124V\\x00x\\x90\\xab\\x00\\xcd\\xef\\x01\\x00#\\x004' ##字节字符串 #int.from_bytes(bytes, byteorder, *, signed=False) #参数解释： bytes是要转换的十六进制； #byteorder：选'big'和'little'，以上例为例，其中big代表正常顺序，即f1ff。little反之，代表反序fff1； #signed：选True、Flase表示是否要区分二进制的正负数含义。即是否要对原二进制数进行原码反码 补码操作。 int.from_bytes(data, 'little') int.from_bytes(data, 'big') x = 94522842520747284487117727783387188 x.to_bytes(16, 'big') x.to_bytes(16, 'little') x = 0x01020304 x.to_bytes(4, 'big') x.to_bytes(4, 'little') 复数的数学运算 j*2=-1 a = complex(2, 4) b = 3 - 5j a.real a.imag a.conjugate() ###共轭复数 两个实部相等，虚部互为相反数的复数互为共轭复数 a + b a * b a / b abs(a) import cmath cmath.sin(a) cmath.cos(a) cmath.exp(a) #Python 的标准数学函数确实情况下并不能产生复数值 math.sqrt(-1) cmath.sqrt(-1) 无穷大与 NaN #创建 a = float('inf') b = float('-inf') c = float('nan') d = float('nan') math.isinf(a) math.isnan(c) a + 45 a * 10 10 / a a/a a + b c + 23 c / 2 math.sqrt(c) print(c==d) 3.8,3.9,3.10 分数运算，大型数组运算，矩阵和线性代数运算 大家自己看看 随机选择 import random values = [1, 2, 3, 4, 5, 6] random.choice(values) ###一个元素 random.choice(values) random.sample(values, 2) ##多个元素 random.shuffle(values) ##打乱顺序 #生成随机整数 random.randint(0,10) #生成 0 到 1 范围内均匀分布的浮点数 random.random() #获取 N 位随机位 (二进制) 的整数 random.getrandbits(10) ###随机种子 random.seed(12345) Datatime 基本的日期与时间转换 from datetime import timedelta a = timedelta(days=2, hours=6) b = timedelta(hours=4.5) c = a + b c.days c.seconds c.seconds / 3600 c.total_seconds() / 3600 from datetime import datetime a = datetime(2012, 9, 23) print(a + timedelta(days=10)) #days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0 b = datetime(2012, 12, 21) d = b - a d d.days now = datetime.today() print(now) print(now + timedelta(minutes=10)) from dateutil.relativedelta import relativedelta a + relativedelta(months=+1) d = relativedelta(b, a) 计算最后一个周五的日期 from datetime import datetime from dateutil.relativedelta import relativedelta from dateutil.rrule import * print(d + relativedelta(weekday=FR(3))) "},"PythonShare/IO&File.html":{"url":"PythonShare/IO&File.html","title":"IO&File","keywords":"","body":"IO&File IO官方文档 异常类官方文档 IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口 stream(流) 所有流对于提供给他们的数据的数据类型都有严格要求, 如果使用二进制流的write()方法写入字符类型的数据,就会引发 TypeError 同步IO与异步IO 因为CPU写入磁盘的速度远远超过 磁盘接收的速度 如果CPU暂停程序等待写入磁盘完成后再执行后续代码,则为同步IO 如果CPU只是告诉磁盘让ta慢慢写, 自己去干别的事了, 则为异步IO 缓存 写入磁盘需要物理开销, 且速度较慢, 对于磁盘IO来说, 策略为留出一部分空间用做磁盘缓存,等磁盘缓存写满了再将其写入磁盘 Python IO模块的IO类型 创造流最简单的方式就是使用 open()函数, 指定对应的编码格式即可创建对应类型的流 Text I/O (文本IO) path = 'e:/Desktop/alongtest.sql' f = open(path, 'r', encoding= 'utf-8') f = io.StringIO('hello world') Binary I/O (二进制IO) path = 'e:/Desktop/怎么回事小老弟.jpg' f = open(path, 'rb') f = io.BytesIO(b'hello world') Raw I/O (原始IO) # 不建议使用 path = 'e:/Desktop/怎么回事小老弟.jpg' f = open(path, 'rb', buffering = 0) I/O操作的类层次结构 ABC(abstract base classes)抽象基类 Inherits Stub Methods Mixin Methods and Properties IOBase fileno,seek,truncate close,closed,flush,isatty,__enter__,__exit__,__iter__,__next__, readable,readline,readlines,seekable,tell,writable,writelines RawIOBase IOBase readinto,write Inherits IOBase Methods, read, readall BufferedIOBase IOBase detach,read,readline,write Inherits IOBase Methods, readinto, readintoline TextIOBase IOBase detach,read,readline,write Inherits IOBase Methods, encoding, errors, newlines 1. IO最顶层的类是抽象基类 IOBase, 其定义了流的基本接口, 但是对于读取流和写入流未作区分 实现该基类时, 如果给定的操作没有实现, 则会引发 UnsupportedOperation 错误 2. RawIOBase继承自IOBase, 用于处理的从流中读取或者向流中写入字节 FileIO是RawIOBase的子类, 为文件系统中的文件提供接口 3. BufferedIOBase处理原始字节流(RawIOBase)上的缓冲, 其子类有 BufferdWriter,BufferedReader,BufferedRWPair等带缓冲区的流 分别是可读的流，可写的流，既可读又可写的流 BufferedRandow提供了一个带缓冲区的接口给随机访问流 BufferedIOBase的另一个子BytesIO是内存中的字节流 4. TextIOBase是IOBase的另一个子类，处理文本形式的字节流，并且处理相应的对字符串的编码和解码操作 TextIOWrapper是从TextIOBase中继承而来，是为带缓冲区的原始流提供的带缓冲区的文本接口 StringIO是内存中的文本流 IO模块类图 IOBase RawIOBase 无缓存的字节流 FileIO 操作系统文件流 BufferedIOBase 缓存的字节流 BytesIO BufferedReader BufferedWriter BufferedRandom BufferedRWPair TextIOBase 编码相关的文本流 StringIO 文本的内存流 TextIOWrapper IO模块的文本IO之StringIO类 文本I/O被读取后，就是在内存中的流 这样的内存流，在调用close()方法后释放内存缓冲区 StringIO类参数 initial_value = '' 缓冲区初始值 newline = '\\n' 换行符 StringIO类额外的方法 getvalue() 返回一个str，包含整个缓冲区的内容 StringIO类的用法 from io import StringIO output = StringIO() output.write('First line.\\n')#写入第一行 print('Second line.', file=output)#写入第二行 print(output.getvalue()) output.close() 补充 1. pickle ## 几乎可以将所有的python对象转化成二进制的形式 import pickle import pandas as pd ## 保存 df = pd.DataFrame({'a':1,'b':2},index=['along']) with open('e:/Desktop/test.pkl','wb') as pickle_file: pickle.dump(df,pickle_file) ## 取数 with open('e:/Desktop/test.pkl','rb') as pickle_file: data = pickle.load(pickle_file) data 2. json # 如果是文件 对应函数应为 dump(), load() import json d = dict(name='Bob', age=20, score=88) json.dumps(d) --'{\"name\": \"Bob\", \"age\": 20, \"score\": 88}' from collections import OrderedDict s = '{\"name\": \"ACME\", \"shares\": 50, \"price\": 490.1}' data = json.loads(s, object_pairs_hook=OrderedDict) data 3. 操作文件和目录 import os os.name # 操作系统类型 os.uname() # 详细的系统信息 os.path.abspath('.') # 查看当前目录的绝对路径 os.path.join('/Users', 'testdir') #在某个目录下创建一个新目录，首先要把新目录的完整路径表示出来 os.mkdir('/Users/testdir') #创建一个目录 os.rmdir('/Users/testdir') #删除一个目录 os.path.split('/Users/file.txt') # 把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名 os.path.splitext('/path/to/file.txt') # 拆分文件拓展名 os.rename('test.txt', 'test.py') # 对文件重命名 os.remove('test.py') # 删除文件 os.path.isdir('test') # 判断是否为目录,一般结合列表推导式使用 [name for name in os.listdir('e:/') if os.path.isdir(os.path.join('e:/', name))] # 筛选出文件夹 [name for name in os.listdir('e:/') if name.endswith('.py')]# 删选出所有python文件 4. open与with open f = open(r'E:/Desktop/alongtest.txt','r',encoding='utf-8') f.read() f.close() # 直接使用open方法需要调用close方法,建议使用以下方法 # 因为with 后面跟的语句返回一个对象, with要求改对象必须有一个__enter__()和__exit__()方法 with open(r'E:/Desktop/alongtest.txt','r',encoding='utf-8') as f: f.read() r read w write a additional b binary 读写都有 "},"PythonShare/Function.html":{"url":"PythonShare/Function.html","title":"Function","keywords":"","body":"Function 函数的参数 函数的参数共有以下几种： 位置参数； 默认参数； 可变参数； 关键字参数； 命名关键字参数； 位置参数 def power(x): return x * x 参数 x 即是一个位置参数 def power(x, n): s = 1 while n > 0: n = n - 1 s = s * x return s x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n； 默认参数 #默认参数的值仅仅在函数定义的时候赋值一次 def power(x, n=2): s = 1 while n > 0: n = n - 1 s = s * x return s n为默认参数 可变参数 def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum calc([1, 2, 3]) def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum calc(1, 2, 3) ###已经有一个list或者tuple，要调用一个可变参数 nums = [1, 2, 3] calc(*nums) 关键字参数 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) person('Michael', 30) output: name: Michael age: 30 other: {} person('Bob', 35, city='Beijing') output: name: Bob age: 35 other: {'city': 'Beijing'} 命名关键字参数 对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。如果要限制关键字参数的名字，就可以用命名关键字参数 def person(name, age, *, city, job): print(name, age, city, job) 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw) def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 函数注解 def add(x:int, y:int) -> int: return x + y 匿名函数 add = lambda x, y: x + y 等同于 def add(x, y): return x + y names = ['David Beazley', 'Brian Jones', 'Raymond Hettinger', 'Ned Batchelder'] sorted(names, key=lambda name: name.split()[-1].lower()) funcs = [lambda x: x+n for n in range(5)] for f in funcs: print(f(0)) #实际效果是运行是 n 的值为迭代的最后一个值,匿名函数是在函数调用是绑定值 funcs = [lambda x, n=n: x+n for n in range(5)] for f in funcs: print(f(0)) #通过使用函数默认值参数形式，lambda 函数在定义时就能绑定到值 偏函数 #减少可调用对象的参数个数 from functools import partial def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc #返回一个新的partial对象，该对象在调用时的行为将类似采用位置参数args和关键字参数keywords对func的调用 def spam(a, b, c, d): print(a, b, c, d) s1 = partial(spam, 1) ##位置参数 s1(2, 3, 4) s2 = partial(spam, d=42) ##关键字参数 s2(1, 2, 3) s3 = partial(spam, 1, 2, d=42) s3(3) 回调函数 回调函数：就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。 通俗理解就是：把一个函数作为参数传给另一个函数，第一个函数称为回调函数 #回调函数一般运用在python的多线程中 举个栗子： def computer(a, b, func): return func(a, b) def max(a, b): return [a, b][a b] def sum(a, b): return str(int(a) + int(b)) if __name__ == \"__main__\": a = input(\"请输入整数a:\") b = input(\"请输入整数b:\") res = computer(a, b, max) print(\"Max of \" + a + \" and \" + b + \" is \" + res) res = computer(a, b, min) print(\"Min of \" + a + \" and \" + b + \" is \" + res) res = computer(a, b, sum) print(\"Sum of \" + a + \" and \" + b + \" is \" + res) 以上四个函数，谁是回调函数？ 偏函数，回调函数组合 from multiprocessing import Pool import time def mycallback(x,y): with open(y, 'a+') as f: #这里是回调函数向文件中写入值 f.writelines(str(x)) def sayHi(num): return num if __name__ == '__main__': e1 = time.time() pool = Pool() for i in range(10): pool.apply_async(sayHi, (i,), callback=partial(mycallback,y='yxy.txt')) #池的多线程 pool.close() pool.join() e2 = time.time() print(float(e2 - e1)) "},"GitTips/":{"url":"GitTips/","title":"GitTips","keywords":"","body":"GitTips "},"GitTips/GitCommon.html":{"url":"GitTips/GitCommon.html","title":"GitCommon","keywords":"","body":"Git 基本的使用 git push 之前先 git pull 1.查看状态 $ git status 2.从线上拉下来最新的与自己的进行合并 $ git pull $ git fetch --只拉取不合并 3.将自己的文件夹添加到暂存区 $ git add . 4.从暂存区将代码提交到 git本地仓库 $ git commit (--all) -m 'modify_reaon' 5.从本地仓库到远程仓库 $ git push [地址] [master(默认)] 6.设置用户名和邮箱 $ git config --global user.name(user.email) 'name/email' ## 1.取消文件修改 $ git checkout 2.查看提交日志 $ git log $ git log --oneline ##简洁版 4.查看所有版本提交日志 $ git reflog 3.回退版本(soft, mixed, hard, keep) $ git reset --hard $ git reset --hard 5.创建dev分支(刚创建时dev分支和master分支的东西是一样的) $ git branch dev 6.切换分支 $ git checkout dev 7.查看分支(输入命令打印后前面带*号的为当前分支) $ git branch 8.合并分支 $ git merge dev 9.删除分支(不能自己删除自己当前分支) $ git branch -d dev 10.生成公私钥(ssh) $ ssh-keygen -t rsa 11.将文件暂存起来放在暂存区(只能在add/commit之后才能暂存)(方便切换到其他分支工作) $ git stash 12.恢复暂存区文件 $ git stash apply (stash@{}n为第几个暂存区文件)(默认恢复最近的文件) $ git stash drop -- $ git stash pop (恢复最近的暂存区文件并删除缓存区中的该文件) $ git stash list (查看暂存区) 13.忽略提交(添加.gitignore文件) $ touch .gitignore $ vim .gitignore(编辑需要忽略的文件,支持正则) 14. 删除git全局配置项 $ git config --global --unset remote.origin.url git命令 Git-tips "},"GitTips/QuicklyBuildGitBook.html":{"url":"GitTips/QuicklyBuildGitBook.html","title":"QuicklyBuildGitBook","keywords":"","body":"GitBook建立并结合GitHub使用 1 安装npm 2 全局安装GitBook npm install -g gitbook-cli 3 本地创建项目 例如PythonCookBook 4 执行命令 gitbook init && gitbook serve (默认4000端口 , 可指定) 5 查看本地启动的服务 127.0.0.1:4000 6 本地创建需要上传到远程仓库的.md文件并上传到远程仓库 git init git remote add origin https://github.com/github账号/项目名(需与本地目录一致).git git add . git commit -m 'init' git push -u origin master 7 本地进行测试并将_book推到供他人访问的分支上 1. 本地gitbook serve启动本地gitbook服务生成静态资源文件 访问 http://127.0.0.1:4000 2. git push 3. git subtree push --prefix=_book origin gh-pages 8 让他人访问 下面地址(对应的个人名字跟文件名改掉) https://yanyanglong.github.io/PythonShare/ 9 图片及主题设置 图片 1. 图片本地保存到某个位置, 例如along.png放到 /PythonShare/image 中 2. 引用时将图片路径导入,默认当前路径为根文件夹路径 故引用图片路径为 /image/along.png 写法为 ![PNG](/image/along.png), 同时在md文件的最开始加入以下内容 --- typora-root-url: .. --- 主题设置 1. 根目录下创建 book.json 文件,\"plugins\": []中写入插件名即可, \"theme-comscore\"为gitbook中一个主题包 详细个性化配置参考 http://www.chengweiyang.cn/gitbook/customize/book.json.html 2. css配置, 如代码行web页面显示长度(下例为个人配置) 根目录下创建website.css 文件,写入 .page-inner {max-width: 1000px;padding: 2px 2px 2px 2px;} 在book.json中 加入 \"styles\": { \"website\": \"website.css\" } - "},"GitTips/GitObject.html":{"url":"GitTips/GitObject.html","title":"GitObject","keywords":"","body":"Git对象 问题 git 在每次提交保存的是什么 .git目录是用来干什么的 git提交生成的像乱码一样的一串字符是什么 Git对象类型 块(blob--binary large object) 用来指代可以包含任意数据的变量或文件,其内部结构会被程序忽略. 一个blob被视为一个黑盒,一个blob保存一个文件的数据, 但不包含任何关于这个文件的元数据, 甚至没有文件名 目录树(tree) 一个目录树代表一层目录信息.记录了blob标识符,路径名和一个目录里所有文件的一些元数据.它可以递归引用其他目录树或子树对象来建立一个包含文件和子目录的完成层次结构 提交(commit) 一个提交对象保存版本库中每一次变化的元数据,包括作者,提交者,提交日期和日志信息. 每个提交对象指向一个目录数对象 标签(tag) 一个标签对象分配一个任意的且人类可读的名字给一个特定对象,通常是一个提交对象. 常用的标签例如 Version-1.0-Ha Git对象图解 Git二次提交对象 Git工作时对象的变化 blob git init find . ## 查看初始化git创建的内容 find ./objects/ echo 'hello world' > hello.txt git add hello.txt find ./objects/ ## 发现多了一个文件夹, 文件夹中的文件为一串字符 当创造了一个文件的时候,Git并不关心文件名,git只关心文件里的内容:'hello world'的字节和换行符. git对这个blob执行一些操作, 计算出它的SHA1散列值,并把散列值的十六进制表示作为文件名放入git对象库中 SHA1散列值保证了内容的唯一性,两个相等的SHA1散列值的概率为2^160(10^48)分之一,就算用一万亿人每秒产生一个blob对象的速度,也要一万亿年,才能产生10^43个blob对象 ## 你可以随时通过散列值从git对象库中取出其内容 git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad(3b18 至少前4个字母) tree Git通过目录树(tree)的对象来跟踪文件的路径名.当使用git add 命令时, git 会立即为文件内容创建一个blob对象,但是不会为tree创建一个对象. git 会更新索引,索引用来跟踪文件的路径名和相应的blob,每次执行命令时,git会用新的路径名和blob信息来更新索引 ## 查看索引 git ls-files -s ## 捕获索引状态并更新tree对象 git write-tree ## 68aba62e560c0ebc3396e8ae9335232cd93a3f60 find .git/objects/ tree层次结构 ## 新建一个文件夹将hello.txt 放到新文件夹中 mkdir subdir cp hello.txt subdir/hello.txt git add subdir/hello.txt git write-tree ## 68aba62e560c0ebc3396e8ae9335232cd93a3f60 可以看到subdir的对象名仍然是上面生成的树对象, 如果你拥有的一个树对象与别人的树对象一模一样 你就可以判断, 你们两个的树对象是一模一样的 find .git/ojbects ## 这里有三个唯一对象, 一个包含 'hello world'的blob, ## 一个包含hello.txt的树,文件里是'hello world' ## 还有一颗树 包含了指向hello.txt的树对象和一个包含 'hello world'的blob ## 提交树对象 echo -n \"commit a file say hello\" | git commit-tree 492413 #158b8896e8ee7be2024cd13f698d4cf3d5520e29 git cat-file -p 158b8 ## 查看提交内容 git show --pretty=fuller 158b8 ## 查看详细提交内容 tag ## 为158b8 提交打标签V1.0 git tag -m 'Tag version 1.0' V1.0 158b8 git rev-parse V1.0 git cat-file -p e8b61a794bcf0188bc62d7bb89b5e20cb5b32343 "},"LinuxTips/":{"url":"LinuxTips/","title":"LinuxTips","keywords":"","body":"LinuxTips "},"LinuxTips/LinuxAliases.html":{"url":"LinuxTips/LinuxAliases.html","title":"Alias","keywords":"","body":"Linux别名 设置别名 alias --查看当前所有别名 alias 别名=\"实际执行的命令\" --添加别名 alias vi=\"vim\" unalias vi --取消vi的别名 unalias -a --取消所有别名 使用alias 直接设置别名并不会永久生效, 在系统重启后alias会重置,需要写到启动的配置文件中才能永久生效 1 获取root权限 2 进入启动配置文件aliases.sh中 vim /etc/profile.d/aliases.sh 3 添加别名 alias 别名=\"实际执行的命令\" 例 alias pushgitbook=\"git subtree push --prefix=_book origin gh-pages\" 注: **别名不能有空格, 等于号两边不能有空格** 4 source /etc/profile.d/aliases.sh 5 pushgitbook 执行的就是实际需要执行的命令了 参考文档 https://blog.csdn.net/sinat_34104446/article/details/83046269 "},"LinuxTips/LinuxChapterOne_SearchCommand.html":{"url":"LinuxTips/LinuxChapterOne_SearchCommand.html","title":"ChapterOne","keywords":"","body":"Linux--ChapterOne 环境变量 echo $PATH 当执行某一命令时,系统搜索命令的路径 shell命令快捷键 Ctrl + a --光标到行首 Ctrl + e --光标到行尾 Ctrl + u --删除光标之前的内容 Ctrl + l --清屏 相当于clear命令 文件搜索命令 locate 文件名 在后台数据库中按文件名搜索, 搜索速度快 /var/lib/mlocate -- locate命令所搜索的后台数据库 数据库每天更新一次, 新建文件需要更新数据库 更新逻辑见 /etc/updatedb.conf 配置文件 PRUNE_BIND_MOUNTS = \"yes\" --开启搜索限制 PRUNEFS --搜索时,不搜索的文件系统 PRUNENAMES -- 搜索时,不搜索的文件类型 PRUNEPATHS -- 搜索时,不搜索的路径 updatedb --更新数据库 find 搜索范围 搜索条件 应避免find命令大范围搜索,会非常消耗系统资源 find是在系统搜索符合条件的文件名, 如果需要匹配,使用通配符匹配,通配符是完全匹配 find /opt/case/analysis/ -name along.log find /opt/case/analysis/ -iname along.log --不区分大小写 find /opt/case/analysis/ -name \"along*\" --使用通配符 find /opt/case/analysis/ -user root --按照所有者搜索 find /opt/case/analysis/ -nouser --查找没有所有者的文件 find /opt/case/analysis/ -mtime +10 -- 查找十天前修改的文件 -10 10天内修改的文件 10 10天当天修改的文件 +10 10天前修改的文件 atime 文件访问时间 ctime 改变文件属性 mtime 修改文件内容 find /opt/case/analysis/ -size 12k --按照文件大小搜索 文件单位 k, M, G 注意只有k是小写,其他都是大写 -12k 小于12KB的文件 12k 等于12KB的文件 -12k 大于12KB的文件 find /opt/case/analysis/ -inum 134318202 --查找i节点为134318202的文件 find /opt/case/analysis/ -size +15k -a -size -20k -- 查找 /opt/case/analysis/ 目录下 大于15KB小于20KB的文件 -exec/ok 命令 {}\\; 规定写法,对搜索结果执行操作,改命令必须是可以处理搜索结果的命令 find /opt/case/analysis/ -size +15k -a -size -20k -exec ls -lh {} \\; 命令搜索命令 whereis/which 命令名 依赖环境变量 搜索命令的命令 whereis 命令名 搜索命令所在路径及帮助文档所在位置 -b 只查找可执行文件 -m 只查找帮助文档 which 命令名 搜索命令所在位置及别名 搜索字符串命令 grep [选项] 字符串 文件名 -i 忽略大小写 -v 排除指定字符串 包含搜索,如果需要匹配,使用正则表达式进行匹配, 正则表达式时包含匹配 grep \"import\" /opt/case/analysis/DataMachine_for_clean/src/along_test.py --搜索包含import的行 grep -v \"import\" ./along_test.py --搜索不包含import的行 帮助命令 man(manuals) man ls NAME 命令名称及功能简要说明 SYNOPSIS 用法说明，可用的选项 DESCRIPTION命令功能的详细说明及意义 SEE ALSO 另外参照 man的级别 1：查看命令的帮助 2：查看可被内核调用的函数的帮助 3：查看函数和函数库的帮助 4：查看特殊文件的帮助（主要是/dev目录下的文件） 5：查看配置文件的帮助 6：查看游戏的帮助 7：查看其它杂项的帮助 8：查看系统管理员可用命令的帮助 9：查看和内核相关文件的帮助 man -f 命令 --查看命令级别和功能简要说明 相当于whatis 命令 man -f ls; man -f passwd man -k passwd --查找所有关键字包含passwd的帮助文档 相当于apropos passwd 命令 --help 如果安装Linux指定语言为中文,则显示中文帮助文档 help shell内部命令 info 会找到所有的帮助文档(各个版本) "},"LinuxTips/LinuxChapterTwo_FileFolder.html":{"url":"LinuxTips/LinuxChapterTwo_FileFolder.html","title":"ChapterTwo","keywords":"","body":"Linux--ChapterTwo 文件/文件夹 创建 文件 touch 文件名 vim/vi 文件名 wq echo \"字符串\" > 文件名 echo \"字符串\" >> 文件名 >将左边的命令结果写入到右边的文件, >>为追加 cp 文件--one 文件--two mv 文件--old 文件--new 文件夹 mkdir 文件夹名 mv 文件夹--old 文件夹--new 删除 Linux没有回收站 一旦删除会无法找回 使用rm -rf一定要注意! ! ! 文件 rm 文件名 文件夹 rm -rf 文件夹名 压缩/解压缩 文件 zip 压缩文件名 源文件 --压缩为.zip格式压缩文件,保留源文件 gzip 源文件 --压缩为.gz格式压缩文件,不保留源文件 gzip -c 源文件 > 压缩文件 --保留源文件 bzip2 源文件 --压缩为.zip格式压缩文件,不保留源文件 bzip2 -k 源文件 --保留源文件 bzip2不能压缩目录 文件夹 zip -r 压缩文件名 源目录 gzip -r 源目录 --压缩目录下所有子文件,但是不能压缩目录 解压缩 zip unzip 压缩文件 gzip gzip -d 压缩文件 gunzip 压缩文件 bzip2 bzip2 -d 压缩文件 -- -k保留压缩文件 bunzip2 压缩文件 -- -k保留压缩文件 打包(解包)后压缩(解压) 打包 tar -cvf 打包文件名 源文件 -c 打包 -v 显示过程 -f 指定打包后的文件名 tar -cvf tar_test.tar along.log 解包 tar -xvf 打包文件名 -x 解打包 tar -xvf tar_test.tar 打包并压缩 tar -zcvf 后缀为.tar.gz的压缩文件 源文件 tar -jcvf 后缀为.tar.bz2 的压缩文件 源文件 -z 压缩为.tar.gz 格式 -j 压缩为.tar.bz2 格式 解压并解包 tar -zxvf 后缀为.tar.gz的压缩文件 tar -jxvf 后缀为.tar.bz2 的压缩文件 "},"LinuxTips/LinuxChapterThree_AuthorityConfiguration.html":{"url":"LinuxTips/LinuxChapterThree_AuthorityConfiguration.html","title":"ChapterThree","keywords":"","body":"Linux--ChapterThree Authority 查看权限 ls -l /dev/ | more #打印的第一列内容如下 -rw-r--r-- 文件类型及权限 - 文件类型(-文件 d目录 l软连接文件) #不常用几乎见不到(b块设备文件,c字符设备文件,s套接字文件,p管道文件) rw- r-- r-- u所有者 g所属组 o其他人 r读 w写 x执行 修改权限 chmod [选项] 模式 文件名 选项 -R 递归 模式 [ugoa][+-=][rwx] [mode=421] chmod [ugoa][+-=][rwx] 文件名 #给[所有者|所属组|其他人][赋予|收回][读|写|执行]权限 chmod [ugoa]=[rwx] 文件名 #同时更改所有者|所属组|其他人权限,中间用逗号隔开 权限数字表示 r ---- 4 w ---- 2 x ---- 1 rwxr-xr-x 755 chmod 755 文件名 常用权限数字 777最高权限 644所有者读写,所属组和其他人读和执行 755所有者读写执行,所属组和其他人读执行 读写执行权限对文件/目录的作用 权限对文件的作用: r:读取文件内容(cat more head tail) w:编辑新增修改文件内容(vi/vim echo) #对文件有写的权限不包含删除,因为其执行权限是上一级目录控制 x:可执行 权限对目录的作用: r:可以查询目录下文件名(ls) w:具有修改目录结构的权限,[新建|删除|重命名]此目录下的文件和目录,剪切(touch rm mv cp) x:可以进入目录(cd) 对文件来说,最高权限是x执行 对目录来说,最高权限是w写, 对目录来说,有意义的权限只有 0,5,7 原则:对于文件,少赋予x权限 对于目录,少赋予w权限 修改文件的所有者 chown 所有者 文件名 chown 所有者:所属组 文件名 chgrp 所属组 文件名 默认权限umask cat /etc/profile #umask在配置初始文件目录时控制权限 规则为最高权限 - umask值 #root用户默认为022,普通用户默认002 1 文件默认最高权限666, 目录默认最高权限777 2 换算规则为 (root用户为例) 文件 rw-rw-rw- - ----w--w- = rw-r--r-- 目录 rwxrwxrwx - ----w--w- = rwxr-xr-x Configuration 登陆时配置文件的加载顺序 登陆进入Linux系统时, 配置文件依次加载, 后写入的变量会造成覆盖 1. 每个文件加载完成后都会调用下一个文件进行执行 2. /etc/目录下的为全局配置文件 ~目录下的为当前用户本地配置文件 3. 正常登陆后依次加载全局配置文件和本地配置文件中的变量,若有重复后定义的将覆盖前定义的变量(绿色线路) 4. 若切换用户,如root切换为其他用户(蓝色线路) 5. 无论如何登陆都会加载语言文件(粉红色线路) "},"LinuxTips/matplotlib包中文编码问题.html":{"url":"LinuxTips/matplotlib包中文编码问题.html","title":"matplotlib包中文编码问题","keywords":"","body":"在Linux上运行matplotlib时会因中文编码问题造成乱码 ,解决方案为下载一个字体包并将其导入到Linux上的matplotlib中 下载arial unicode ms.ttf 的字体 拷贝一份到matplotlib中 ,路径为 cp arial\\ unicode\\ ms.ttf /root/.virtualenvs/datatimer/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf 重命名 cd /root/.virtualenvs/datatimer/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf cp arial\\ unicode\\ ms.ttf Vera.ttf 删除字体缓存 cd ~/.cache/matplotlib/ rm -rf fontlist-v300.json python脚本中添加 import matplotlib.pyplot as plt plt.rcParams['font.family'] = ['Arial Unicode MS', 'sans-serif'] # 全局设置支持中文字体，默认 sans-serif "},"LinuxTips/Hadoop/":{"url":"LinuxTips/Hadoop/","title":"Hadoop","keywords":"","body":"Hadoop "},"LinuxTips/Hadoop/搭建Hadoop.html":{"url":"LinuxTips/Hadoop/搭建Hadoop.html","title":"初始化配置","keywords":"","body":"搭建Hadoop 搭建前准备(只针对Windows用户) 1. VMware Workstation Pro(最新版) https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html https://blog.csdn.net/qq_40950957/article/details/80467513 #博客参考 2. centos镜像文件(centos7-x版本) http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso 3. jdk (选择7-x以上版本,Linux .tar.gz的文件下载) https://www.oracle.com/technetwork/java/javase/downloads/index.html 4. Hadoop(2.7.0及以上版本) http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-2.7.6/hadoop-2.7.6.tar.gz #安装步骤参考博客 https://blog.csdn.net/acecai01/article/details/82696363 开始安装 1. 安装 VMware Workstation Pro 2. 新建虚拟机并配置内存,处理器.硬盘,网络,指定Centos光盘位置 3. 开启虚拟机, 配置时间,分区,网络连接方式,桌面安装找到Desktop安装(纯字符界面使用Minimal安装) 4. 在 VMware Workstation Pro 菜单栏找到虚拟机,安装 VMwareTools Centos中找到 VMwareTools-x.x.0-xx.tar.gz 文件(/run/media目录下)执行 tar -zxvf .tar.gz文件 cd vmware-tools-distrib && ./vmware-install.pl 5. 第一次运行需运行 /usr/bin/vmware-config-tools.pl 命令配置 VMwareTools 6. /usr/bin/vmware-user && startx 7. 将文件从windows桌面拖到Centos桌面 8. 配置免密登陆 cd ~/.ssh/ && ssh-keygen -t rsa cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys 9. 安装jdk 查找自带的jdk rpm -qa | grep jdk 卸载自带openjdk yum -y remove java java-xxx-openjdk-xx 将下载的jdk拖到桌面并解压 tar -zxvf jdk-7u80-linux-x64.tar.gz -C /opt 配置环境变量 vim /etc/profile 行首添加 #Set JDK PATH export JAVA_HOME=/opt/jdk1.7.0_80 export CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin source /etc/profile update-alternatives --install /usr/bin/java java /opt/jdk1.7.0_80/bin/java 60 update-alternatives --config java 10.关闭防火墙 chkconfig --level 35 iptables off vim /etc/selinux/config #找到SELINUX行修改为：SELINUX=disabled 11. 安装Hadoop http://dblab.xmu.edu.cn/blog/install-hadoop/ #参考文章 将下载的hadoop包拖到桌面并解压缩 tar -zxvf hadoop-2.7.6.tar.gz -C /opt mv /opt/hadoop-2.7.0 /opt/hadoop 配置环境变量 vim /etc/profile 行首添加 #Set HADOOP PATH export HADOOP_HOME=/opt/hadoop export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:/opt/hadoop/sbin:/opt/hadoop/bin source /etc/profile gedit /etc/hostname 更改为Master gedit /etc/hosts 最后添加 192.168.121.1 Master 192.168.122.1 Slave1 gedit core-site.xml 添加 hadoop.tmp.dir file:/usr/local/hadoop/tmp Abase for other temporary directories. fs.defaultFS hdfs://localhost:9000 gedit hdfs-site.xml 添加 dfs.replication 1 dfs.namenode.name.dir file:/usr/local/hadoop/tmp/dfs/name dfs.datanode.data.dir file:/usr/local/hadoop/tmp/dfs/data dfs.namenode.http.address 127.0.0.1:50070 /opt/hadoop/bin/hdfs namenode -format #配置完成后初始化NameNode /opt/hadoop/sbin/start-dfs.sh #开启 NameNode 和 DataNode 守护进程 jps 查看 NameNode 和 DataNode 和 SecondaryNameNode 打开 http://Master:50070 即可查看 NameNode 和 Datanode 信息 12. 运行Hadoop伪分布式实例 运行自带实例: hadoop jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+' 运行自己写的python mapreduce程序 hdfs dfs -mkdir -p input/test.txt 本地生成目录及文件 along_mk 其下两个文件 map_wctest.py 和 reduce_wctest.py 1. shell运行 echo 'a b c a b c e a e'| python map_wctest.py | sort -k1,1 | python reduce_wctest.py 2. 上传到hdfs上运行 hdfs dfs -put /root/along_mk along_mk /opt/hadoop/bin/hadoop jar /opt/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.7.6.jar -files \"map_wctest.py,reduce_wctest.py\" -input input/test.py -output output -mapper \"python /root/along_mr/map_wctest.py\" -reducer \"python /root/along_mr/reduce_wctest.py\" hdfs dfs -cat output/part-00000 查看运行结果 虚拟机配置 along_mk目录下的map和reduce python文件 #map_wctest.py import sys def read_input(file): for line in file: yield line.split() def main(): data = read_input(sys.stdin) for words in data: for word in words: print(f'{word}\\t1') if __name__ == '__main__': main() #reduce_wctest.py import sys from itertools import groupby from operator import itemgetter def read_mapper_output(file, sep='\\t'): for line in file: yield line.rstrip().split(sep, 1) def main(): data = read_mapper_output(sys.stdin) for current_word, group in groupby(data, itemgetter(0)): total_count = sum(int(count) for current_word, count in group) print(f'{current_word}\\t{total_count}') if __name__ == '__main__': main() "},"LinuxTips/Hadoop/Docker.html":{"url":"LinuxTips/Hadoop/Docker.html","title":"Docker","keywords":"","body":"Docker Docker概念 Docker--从入门到实践 Docker配置Mysql 1. docker pull mysql:latest #拉取最新版mysql 2. docker images #查看镜像文件 3. docker run -p 3306:3306 --name along_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql #启动mysql服务并映射端口号为3306,启动name为along_mysql,设置初始密码为123456 4. docker ps -a #查看启动的服务,如果上一步报错,有可能是关闭了docker容器但是还未退出,STATUS为Exited 如果发现有关闭了容器但是还未退出的容器,使用 docker rm 删除 --批量删除 docker container prune --批量删除 docker ps -a | sed '/^CONTAINER/d' | grep \"Exited\" | gawk '{cmd=\"docker rm \"$1; system(cmd)}' 5. 不建议直接进入docker容器内部修改内容,如果需要修改密码/CURD数据,使用宿主机/外部访问宿主机ip:3306端口操作!!! ##宿主机/外部访问docker启动的mysql服务 1. 宿主机上安装mysql yum install mysql-community-server service mysqld start #停止service mysqld stop service mysqld status #查看状态 #如果centos上安装mariadbs数据库 删除yum remove mariadb* 2. 停止docker上的mysql服务 docker stop mysql / docker rm #因为宿主机上启动mysql服务也是用3306端口,如果不终端docker的mysql服务,宿主机上无法启动mysql并报错 3. 宿主机上登陆mysql cat /var/log/mysqld.log | grep password --获取安装时的用户密码,假设为-dz%-KLw0fe mysql -uroot -p --> -dz%-KLw0fe ALTER USER \"root\"@\"localhost\" IDENTIFIED BY \"123456\"; #修改密码 #mysql8.*+在修改密码时会报错 \"Your password does not satisfy the current policy requirements\" ALTER USER \"root\"@\"localhost\" IDENTIFIED BY \"Root_123456\"; 先修改为指定强度的密码,然后修改密码强度 set global validate_password.policy=0; 　　　　 set global validate_password.length=1; 　　　　 ALTER USER \"root\"@\"localhost\" IDENTIFIED BY \"123456\"; #修改为简单密码 4. 宿主机上mysql服务中断, service mysqld stop, 启动docker上mysql服务 5. 设置外部访问,如不设置,脱离虚拟机使用其他工具如Navicat/Mysql-Front连接会报错\"1251-client does not support authentication protocol requested by server\" 宿主机连接docker服务 mysql -h192.168.112.131 -uroot -p123456 #192.168.112.131为你当前虚拟机的IP地址 使用ifconfig查看到inet select host,user,plugin,authentication_string from mysql.user; #查看用户信息 update user set host = '%' where user ='root'; #host不设限,都可访问 flush privileges; ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456' 6. 使用Navicat 连接 192.168.112.131 root 123456 Docker部署mindoc(wiki) 1. docker pull registry.cn-hangzhou.aliyuncs.com/mindoc/mindoc:v0.12 #使用阿里云拉取mindoc docker镜像 2. mysql -h192.168.112.131 -uroot -p123456 #创建wiki所需数据库 (mysql)>CREATE DATABASE mindoc_db 3. docker run -p 8181:8181 -e MYSQL_PORT_3306_TCP_ADDR=192.168.112.131 -e MYSQL_PORT_3306_TCP_PORT=3306 -e MYSQL_INSTANCE_NAME=mindoc_db -e MYSQL_USERNAME=root -e MYSQL_PASSWORD=123456 -e httpport=8181 -d registry.cn-hangzhou.aliyuncs.com/mindoc/mindoc:v0.12 #启动mindoc DB_ADAPTER 制定 DB MYSQL_PORT_3306_TCP_ADDR MySQL地址 MYSQL_PORT_3306_TCP_PORT MySQL端口号 MYSQL_INSTANCE_NAME MySQL数据库名称 MYSQL_USERNAME MySQL账号 MYSQL_PASSWORD MySQL密码 HTTP_PORT 程序监听的端口号 4. 访问 192.168.112.131:8181 "},"QuestionBank/":{"url":"QuestionBank/","title":"QuestionBank","keywords":"","body":"Introduction 定期选择力扣题目，共同研究学习，提高代码掌控力和逻辑思维能力，更好更快的写出优雅贵气的代码 "},"QuestionBank/20190807.html":{"url":"QuestionBank/20190807.html","title":"20190807","keywords":"","body":"from leetcode： Q:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb A: class Solution: def longestPalindrome(self, s: str) -> str: n = len(s) dp = [[0] * n for _ in range(n)] max_len = float(\"-inf\") res = \"\" for i in range(n): for j in range(i, -1, -1): if s[i] == s[j] and (i - j max_len: max_len = i - j + 1 res = s[j:i + 1] return res "}}