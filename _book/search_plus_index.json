{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is for advanced data analysts ... "},"Databases/":{"url":"Databases/","title":"Databases","keywords":"","body":"Introduction mysql hive presto mongodb redis "},"Databases/Presto简介_时间函数.html":{"url":"Databases/Presto简介_时间函数.html","title":"Presto简介 时间函数","keywords":"","body":"Presto简介 Presto是什么 Presto是由Facebook开发的分布式SQL 查询引擎，用来进行高速、实时的数据分析 Presto的产生是为了解决Hive的MapReduce模型太慢的问题 Presto是一个计算引擎，它不存储数据，通过丰富的Connector获取第三方的数据，并支持扩展 注意点：查询引擎，非数据库，不存储数据,获取第三方的数据 hive :（基于Hadoop的数据仓库工具）提供存储、查询 Presto优点 支持标准SQL，降低使用门槛 可以连接多种数据源，包括Hive、RDBMS（Mysql、Oracle、Tidb等）、Kafka、MongoDB、Redis等 一个低延迟高并发的内存计算引擎，相比Hive，执行效率要高很多 注意点：连接多种数据源，内存计算 Presto模型 查询示例：select \\ from hive.dwd_db_hfjydb.view_tms_contract_payment a left join hive.dwd_db_hfjydb.view_tms_contract b on a.contract_id = b.contract_id* Catalog:就是数据源。Hive，Mysql是数据源，Hive 和Mysql都是数据源类型，可以连接多个Hive和多个Mysql。 Schema：相当于一个数据库实例，一个Schema包含多张数据表。 Table：数据表，与一般意义上的数据库表相同。 Presto日期时间函数 时区转换 格式: SELECT timestamp '2019-08-01 01:00 UTC' AT TIME ZONE 'America/Los_Angeles' UTC:格林威治时间/称世界统一时间、世界标准时间 比北京时间慢8个小时 ​ 示例:SELECT now() AT TIME ZONE 'America/Los_Angeles -- 比北京慢15小时北京时间 当前日期时间 函数 now()/ current_timestamp 返回timestamp with time zone** current_date：返回当前日期，只包含年月日 current_time: 返回time with time zone 示例:SELECT NOW() \"now\", current_timestamp \"current_timestamp\" , current_date \"current_date\", current_time \"current_time\" 注意: mysql:now()/sysdate(),curtime(),curdate() presto sql:current_date,current_time,current_timestamp函数都没有括号 时间格式转换 函数:cast(value AS type) → type 显式把value转换到type类型。 Presto SQL大的“特点”：完全不同的数据类型之间不能比较，相似的数据类型一般可以比较。 date与varchar完全不同,不可以比较 cast('2019-08-01' as date),date('2019-08-01' ) cast('2019-08-01 16:00:00.000' as TIMESTAMP) cast('2019-08-01 16:00:00.000' as date) 报错 需要截取 注意:长转短需要截取,短转长会自动补齐 示例:select current_date > cast('2019-07-31' as date) ; ​ select current_date > date'2019-07-31' ; ​ select '2019-08-01' > '2019-07-31' ; ​ select substr(lp.adjust_start_time,1,10) ,lp.adjust_start_time ​ from dwd_db_hfjydb.lesson_plan lp ​ where substr(lp.adjust_start_time,1,10) = '2019-08-01' limit 1; 截取函数 ​ date_trunc(unit, x) 返回x截取到单位unit之后的值 函数 支持如下单位： 单位 Example Truncated Value second 2001-08-22 03:04:05.000 minute 2001-08-22 03:04:00.000 hour 2001-08-22 03:00:00.000 day 2001-08-22 00:00:00.000 week 2001-08-20 00:00:00.000 month 2001-08-01 00:00:00.000 quarter 2001-07-01 00:00:00.000 year 2001-01-01 00:00:00.000 示例:select date_trunc('hour',current_timestamp); ​ select date_trunc('week',current_timestamp); ​ select date_trunc('month',current_timestamp); ​ select date_trunc('quarter',current_timestamp); 间隔函数 date_add(unit, value, timestamp)→ [same as input] 在timestamp的基础上加上value个unit。如果想要执行相减的操作，可以通过将value赋值为负数来完成。 函数支持如下所列的间隔单位： Unit Description second Seconds minute Minutes hour Hours day Days week Weeks month Months quarter Quarters of a year year Years 示例: select date_add('day',1,now()); ​ select date_add('hour',-1,now()); ​ select date_add('quarter',1,now()); -- 增加一个季度即增加三个月 时间差函数 date_diff(unit, timestamp1, timestamp2) 返回 (timestamp2 - timestamp1) 之后的值，该值的表示单位是unit. 注意:unit加引号 ,mysql 中 DATEDIFF(date1,date2) 是date1-date2 示例: select date_diff('hour', TIMESTAMP'2018-08-08 08:08:08', TIMESTAMP'2018-08-08 00:00:00') ; ​ select date_diff('quarter', TIMESTAMP'2019-08-08 08:08:08', TIMESTAMP'2019-12-02 06:00:00.000') ; 日期格式化函数 date_format(timestamp, format) → varchar 使用format指定的格式，将timestamp格式化成字符串 支持类型单位 注意:%D %U %u %V %X %w 暂不支持* 分类符 说明 %a Abbreviated weekday name (Sun .. Sat) %b Abbreviated month name (Jan .. Dec) %c Month, numeric (0 .. 12) %D Day of the month with English suffix (0th, 1st, 2nd, 3rd, …) %d Day of the month, numeric (00 .. 31) %e Day of the month, numeric (0 .. 31) %f Fraction of second (6 digits for printing: 000000 .. 999000; 1 - 9 digits for parsing: 0 .. 999999999) %H Hour (00 .. 23) %h Hour (01 .. 12) %I Hour (01 .. 12) %i Minutes, numeric (00 .. 59) %j Day of year (001 .. 366) %k Hour (0 .. 23) %l Hour (1 .. 12) %M Month name (January .. December) %m Month, numeric (00 .. 12) %p AM or PM %r Time, 12-hour (hh:mm:ss followed by AM or PM) %S Seconds (00 .. 59) %s Seconds (00 .. 59) %T Time, 24-hour (hh:mm:ss) %U Week (00 .. 53), where Sunday is the first day of the week %u Week (00 .. 53), where Monday is the first day of the week %V Week (01 .. 53), where Sunday is the first day of the week; used with %X %v Week (01 .. 53), where Monday is the first day of the week; used with %x %W Weekday name (Sunday .. Saturday) %w Day of the week (0 .. 6), where Sunday is the first day of the week %X Year for the week where Sunday is the first day of the week, numeric, four digits; used with %V %x Year for the week, where Monday is the first day of the week, numeric, four digits; used with %v %Y Year, numeric, four digits %y Year, numeric (two digits) %% A literal % character %x x, for any x not listed above 示例:SELECT date_format(current_timestamp,'%Y-%m-%d %W %H:%i:%s') date_parse(string, format) → timestamp 按照format指定的格式，将字符串string解析成timestamp 注意:两边形式要一样 date_parse('2019-08-01 ','%Y-%m-%d %H:%i:%s') 会报错 示例: SELECT date_parse('2019-08-01 08:08:08','%Y-%m-%d %H:%i:%s'); 抽取函数 extract(field FROM x)→ bigint(整数) 从x中返回域field 抽取函数支持的数据类型取决于需要抽取的域。大多数域都支持日期和时间类型。 可以使用抽取函数来抽取如下域： Field Description YEAR year() QUARTER quarter() MONTH month() WEEK week() DAY day() DAY_OF_MONTH day() DAY_OF_WEEK day_of_week() DOW day_of_week() DAY_OF_YEAR day_of_year() DOY day_of_year() YEAR_OF_WEEK year_of_week() YOW year_of_week() HOUR hour() MINUTE minute() SECOND second() TIMEZONE_HOUR timezone_hour() :表示时区偏移小时量 TIMEZONE_MINUTE timezone_minute() 示例: select extract(year FROM current_timestamp) ,extract(month from DATE'2019-08-01'),extract(DAY FROM now()), extract(WEEK from now()),extract(doy FROM now()); ​ select extract(TIMEZONE_HOUR FROM now()) \"时区偏移小时量\"; 便利的抽取函数: 格式 day(x) → bigint 返回指定日期在当月的天数 day_of_month(x) → bigint day(x)的另一种表述 day_of_week(x) → bigint 返回指定日期对应的星期值，值范围从1 (星期一) 到 7 (星期天). day_of_year(x) → bigint 返回指定日期对应一年中的第几天，值范围从1到 366. dow(x) → bigint day_of_week()的另一种表达 doy(x) → bigint day_of_year()的另一种表达 hour(x) → bigint 返回指定日期对应的小时，值范围从1到 23 minute(x) → bigint 返回指定日期对应的分钟 month(x) → bigint 返回指定日期对应的月份 quarter(x) → bigint 返回指定日期对应的季度，值范围从1到 4 second(x) → bigint 返回指定日期对应的秒 timezone_hour(timestamp) → bigint 返回从指定时间戳对应时区偏移的小时数 timezone_minute(timestamp) → bigint 返回从指定时间戳对应时区偏移的分钟数 week(x) → bigint 返回指定日期对应一年中的ISO week，值范围从1到 53 week_of_year(x) → bigint week的另一种表述 year(x) → bigint 返回指定日期对应的年份 year_of_week(x) → bigint 返回指定日期对应的ISO week的年份 yow(x) → bigint year_of_week()的另一种表达 示例:select year(now()) ,month(now()),day(now()),doy(now()),quarter(now()),week(now()); 补充: sum() over() sum() over(PARTITION BY columnA order by columnB ) :类似于Python中 cumsum(),实现累计和功能 示例: SELECT aa.\"部门\", aa.date, aa.\"当月业绩\", sum( aa.\"当月业绩\" ) over ( PARTITION BY aa.\"部门\" ORDER BY aa.date ) \"累计和\", sum( aa.\"当月业绩\" ) over ( PARTITION BY aa.\"部门\" ) \"三天总业绩\", cast(round( aa.\"当月业绩\" * 100 / sum( aa.\"当月业绩\" ) over ( PARTITION BY aa.\"部门\" ), 2 ) AS VARCHAR ) || '%' \"日占比\" FROM ( SELECT substr( sd.department_name, 1, 7 ) \"部门\", substr( tcp.pay_date, 1, 10 ) date, sum( tcp.sum / 100 ) \"当月业绩\" FROM dwd_db_hfjydb.view_tms_contract_payment tcp LEFT JOIN dwd_db_hfjydb.view_tms_contract tc ON tc.contract_id = tcp.contract_id LEFT JOIN dwd_db_hfjydb.view_user_info ui ON ui.user_id = tc.submit_user_id LEFT JOIN dwd_db_hfjydb.sys_user_role sur ON ui.user_id = sur.user_id LEFT JOIN dwd_db_hfjydb.sys_role sr ON sur.role_id = sr.role_id LEFT JOIN dwd_db_hfjydb.sys_department sd ON sr.department_id = sd.department_id WHERE substr( tcp.pay_date, 1, 10 ) >= '2019-07-01' AND substr( tcp.pay_date, 1, 10 ) AND tc.STATUS NOT IN ( 7, 8 ) -- 剔除合同终止和废弃 AND tcp.pay_status IN ( 2, 4 ) AND ui.account_type = 1 AND regexp_like ( sd.department_name, '江苏销售' ) AND sd.department_name NOT LIKE '%考核%' GROUP BY 1,2 ) aa 官方文档 http://prestodb.jd.com/docs/current/index.html* "},"DataAnalystHelper/":{"url":"DataAnalystHelper/","title":"DataAnalystHelper","keywords":"","body":"Introduction 本项目从BI层面提供数据服务支持方面, 封装了常用方法 使数据分析师在日常工作中快速搭建数据服务来专注业务逻辑 代码主要对以下几大点做封装 数据库连接查询(Mysql , Hive) 数据表生成(Mysql中间表) DataFrame常用方法二次封装(时间函数, 输出Excel, merge...) 输出内容相关(html模板渲染, 钉钉自定义机器人) ...... 具体代码请前往 https://github.com/advanceddataanalysts/AdvancedPython "},"GitTips/":{"url":"GitTips/","title":"GitTips","keywords":"","body":"GitTips "},"GitTips/GitCommon.html":{"url":"GitTips/GitCommon.html","title":"GitCommon","keywords":"","body":"Git 基本的使用 git push 之前先 git pull 1.查看状态 $ git status 2.从线上拉下来最新的与自己的进行合并 $ git pull $ git fetch --只拉取不合并 3.将自己的文件夹添加到暂存区 $ git add . 4.从暂存区将代码提交到 git本地仓库 $ git commit (--all) -m 'modify_reaon' 5.从本地仓库到远程仓库 $ git push [地址] [master(默认)] 6.设置用户名和邮箱 $ git config --global user.name(user.email) 'name/email' ## 1.取消文件修改 $ git checkout 2.查看提交日志 $ git log $ git log --oneline ##简洁版 4.查看所有版本提交日志 $ git reflog 3.回退版本(soft, mixed, hard, keep) $ git reset --hard $ git reset --hard 5.创建dev分支(刚创建时dev分支和master分支的东西是一样的) $ git branch dev 6.切换分支 $ git checkout dev 7.查看分支(输入命令打印后前面带*号的为当前分支) $ git branch 8.合并分支 $ git merge dev 9.删除分支(不能自己删除自己当前分支) $ git branch -d dev 10.生成公私钥(ssh) $ ssh-keygen -t rsa 11.将文件暂存起来放在暂存区(只能在add/commit之后才能暂存)(方便切换到其他分支工作) $ git stash 12.恢复暂存区文件 $ git stash apply (stash@{}n为第几个暂存区文件)(默认恢复最近的文件) $ git stash drop -- $ git stash pop (恢复最近的暂存区文件并删除缓存区中的该文件) $ git stash list (查看暂存区) 13.忽略提交(添加.gitignore文件) $ touch .gitignore $ vim .gitignore(编辑需要忽略的文件,支持正则) 14. 删除git全局配置项 $ git config --global --unset remote.origin.url git命令 Git-tips "},"GitTips/QuicklyBuildGitBook.html":{"url":"GitTips/QuicklyBuildGitBook.html","title":"QuicklyBuildGitBook","keywords":"","body":"GitBook建立并结合GitHub使用 1 安装npm 2 全局安装GitBook npm install -g gitbook-cli 3 本地创建项目 例如PythonCookBook 4 执行命令 gitbook init && gitbook serve (默认4000端口 , 可指定) 5 查看本地启动的服务 127.0.0.1:4000 6 本地创建需要上传到远程仓库的.md文件并上传到远程仓库 git init git remote add origin https://github.com/github账号/项目名(需与本地目录一致).git git add . git commit -m 'init' git push -u origin master 7 本地进行测试并将_book推到供他人访问的分支上 1. 本地gitbook serve启动本地gitbook服务生成静态资源文件 访问 http://127.0.0.1:4000 2. git push 3. git subtree push --prefix=_book origin gh-pages 8 让他人访问 下面地址(对应的个人名字跟文件名改掉) https://yanyanglong.github.io/PythonShare/ 9 图片及主题设置 图片 1. 图片本地保存到某个位置, 例如along.png放到 /PythonShare/image 中 2. 引用时将图片路径导入,默认当前路径为根文件夹路径 故引用图片路径为 /image/along.png 写法为 ![PNG](/image/along.png), 同时在md文件的最开始加入以下内容 --- typora-root-url: .. --- 主题设置 1. 根目录下创建 book.json 文件,\"plugins\": []中写入插件名即可, \"theme-comscore\"为gitbook中一个主题包 详细个性化配置参考 http://www.chengweiyang.cn/gitbook/customize/book.json.html 2. css配置, 如代码行web页面显示长度(下例为个人配置) 根目录下创建website.css 文件,写入 .page-inner {max-width: 1000px;padding: 2px 2px 2px 2px;} 在book.json中 加入 \"styles\": { \"website\": \"website.css\" } - "},"PythonShare/":{"url":"PythonShare/","title":"PythonShare","keywords":"","body":"PythonShare "},"PythonShare/Dictionary.html":{"url":"PythonShare/Dictionary.html","title":"Dictionary","keywords":"","body":"Dictionary Q 构建字典时 创建字典引用其他字典时,不知道key是否存在,如果key存在则去重 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: dic = {} def add_dic(pairs,dic): for key,value in pairs.items(): if key not in dic: dic[key] = [] dic[key].append(value) dic[key] = list(set(dic[key])) return dic add_dic(pairs=pairs,dic=dic) add_dic(pairs=pairs1,dic=dic) ## 方法二: ## 代码结构更清晰 from collections import defaultdict s_dict = defaultdict(set) def s_add_dic(pairs,dic): for key,value in pairs.items(): s_dict[key].add(value) return dic s_add_dic(pairs=pairs,dic=s_dict) s_add_dic(pairs=pairs1,dic=s_dict) Q 构建字典时 保证字典有序 ## 方法一: ## python3.6之后字典会按照构建顺序自动排序 dic = {} dic['a'] = 1 dic['b'] = 2 dic['c'] = 3 dic['d'] = 4 print(dic) ## {'a': 1, 'c': 3, 'b': 2, 'd': 4} ## 方法二: ## 必按照添加顺序排序 w+s ## OrderedDict内部维护了双向链表,根据加入顺序排列键的位置,但是大小是普通字典的2倍大 from collections import OrderedDict s_dic = OrderedDict() s_dic['a'] = 1 s_dic['b'] = 2 s_dic['c'] = 3 s_dic['d'] = 4 print(dict(s_dic)) ## {'a': 1, 'b': 2, 'c': 3, 'd': 4} Q 构建字典时 从已有的字典中提取子集 ## 字典推导式 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} dic = {key:value for key,value in pairs.items() if key in ['apple','orange']} print(dic) Q 构建字典时 字典映射 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} pairs1 = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999998, 'along':'refuse'} ## 方法一: ## 构建新的字典对象/在原始字典上修改 new_pairs = dict(pairs1) new_pairs.update(pairs) print(new_pairs) ## 方法二: ## ChainMap使用原始字典映射,更改原始字典同步反应到映射对象上 from collections import ChainMap cm_pairs = ChainMap(pairs,pairs1) print({key:value for key,value in cm_pairs.items()}) ## 对ChaipMap对象的修改只会反映到第一个dict对象上, 反之亦然, 对字典的修改只有第一个的修改会反映到ChaipMap对象上 cm_pairs['tuberose'] = 99999999999999999999 print(cm_pairs,'\\n',pairs,'\\n',pairs1) pairs1['tuberose'] = 9999999888888888999999999999 print({key:value for key,value in cm_pairs.items()}) Q 对字典进行计算 将字典的key替换, value不变 pairs = {'apple':2.5, 'orange':2.2, 'banana':2.6, 'tuberose':999999999} ## 方法一: pairs['new_apple'] = pairs.pop('apple') ## 方法二: pairs.update({'new_apple':pairs.pop(\"apple\")}) Q 对字典进行计算 求value最值对应的key:value对 prices = {'A':2.22,'B':9.06,'C':0.06,'D':9.06,'E':0.06} print(max(prices)) ## 'E' ## 多条记录value相等时 按照第二个参数大小排序 print(max(zip(prices.values(),prices.keys()))) ## (9.06, 'D') ## 多条记录value相等时 取第一次出现的键值对 print(max(prices, key=lambda k: prices[k]), prices[max(prices, key=lambda k: prices[k])]) ## B 9.06 Q 对字典进行计算 求两个/多个字典的相同点 a_dict = {'x':1, 'y':2, 'z':3} b_dict = {'x':1, 'y':2, 'w':3} c_dict = {'x':1} print(a_dict.keys() & b_dict.keys()) ##{'x', 'y'} print(a_dict.keys() & b_dict.keys() & c_dict.keys()) ##{'x'} print(a_dict.items() & b_dict.items()) ## {('x', 1), ('y', 2)} c = {key:a_dict[key] for key in a_dict.keys() - {'z','w'}} print(c) ##{'x': 1, 'y': 2} Q 对字典进行计算 通过公共键对字典列表排序 rows = [{'fname':11, 'lname':2, 'uid':1003}, {'fname':111, 'lname':22, 'uid':1004}, {'fname':111, 'lname':222, 'uid':1002}, {'fname':11, 'lname':222, 'uid':1003},] ## 方法一: sorted(rows, key=lambda x:x['uid']) sorted(rows, key=lambda x:(x['fname'],x['lname'])) ## 方法二: ## 运行速度更快,性能好(max,min也同样支持) from operator import itemgetter sorted(rows, key=itemgetter('uid'), reverse=True) sorted(rows, key=itemgetter('fname','lname'),reverse=False) ## 方法三: ## 抓成df,排序结束再用df.to_dict()/df.to_json()转 import pandas as pd data = pd.DataFrame(rows) data.sort_values(by=['uid'],inplace=True) data.to_dict(orient='records') Q 对字典进行计算 根据键对数据进行分组 rows = [{'address':'zhongguancun', 'date':'07/01/2018'}, {'address':'putuo', 'date':'07/02/2018'}, {'address':'wangfujing', 'date':'07/01/2018'}, {'address':'jingan', 'date':'07/04/2018'},] ## 方法一: ## sort+itemgetter+groupby from operator import itemgetter from itertools import groupby rows.sort(key=itemgetter('date')) ##分组前需要先排序,因为groupby()只能检查连续的项 for key, value in groupby(rows, key=itemgetter('date')): print(key) for i in value: print(' ',i) ## 方法二: ## 转成df,groupby之后再转成字典 import pandas as pd data = pd.DataFrame(rows) for key,value in data.groupby(by=['date']): print(key,list(value.T.to_dict().values())) "},"PythonShare/DataStructure.html":{"url":"PythonShare/DataStructure.html","title":"DataStructure","keywords":"","body":"DataStructure * 解压 解压序列赋值给多个变量(作用可迭代对象) p = (4, 5) x, y = p data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] name, shares, price, date = data name, shares, price, (year, mon, day) = data s = 'Hello' a, b, c, d, e = s # 变量个数和序列元素的个数不匹配，会产生一个异常 p = (4, 5) x, y, z = p # 部分解压 data = [ 'ACME', 50, 91.1, (2012, 12, 21) ] _, shares, price, _=data 解压可迭代对象赋值给多个变量 record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212') record = ('Dave', 'dave@example.com') record = ('Dave', 'dave@example.com','773-555-1212', '847-555-1212','773-555-1213', '847-555-1213') name, email, *phone_numbers = record phone_numbers #星号表达式也能用在列表的开始部分 *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current trailing, *current = [10, 8, 7, 1, 9, 5, 10, 3] trailing current line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false' uname, *fields, homedir, sh = line.split(':') 双向队列 deque:double-ended queue #双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。 #将队列的两端分别称为前端和后端，两端都可以入队和出队 栈:栈是一种后进先出的数据结构，我们可以借助list来实现栈 stack = [] stack.append(item1) # 入栈 stack.pop() # 出栈，返回结果是出栈元素 peak = stack[-1] # 返回栈顶元素 队列:队列是一种先进先出的数据结构，我们可以借助list来实现队列 queue = [] queue.append(item) # 入队 queue.pop(0) # 出队，返回结果是出队元素 在队列两端插入或删除元素时间复杂度都是 O(1) ， 而在列表的开头插入或删除元素的时间复杂度为 O(N) 。 from collections import deque q = deque(maxlen=3) q.append(1) q.append(2) q.append(3) q.append(4) q.append(5) #q.appendleft(6) ###默认从右边 q.clear() #清空队列 q.count(n) #在队列中统计元素的个数，n表示统计的元素 q.extend(n) #从右边扩展队列，n表示扩展的队列 q.extendleft(n) #从左边扩展队列，n表示扩展的队列 q.pop() #队尾元素删去 q.popleft() #队头元素删去 Heap & Heapq 查找最大或最小的 N 个元素 堆： 1.建立在完全二叉树的基础上(若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数， 第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。) 2.排序算法的一种，也是稳定效率最高的一种 3.可用于实现STL中的优先队列(priority_queue) STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。 它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的 **优先队列**：一种特殊的队列，队列中元素出栈的顺序是按照元素的优先权大小，而不是元素入队的先后顺序 4.两类： a.最大堆： ①根的值大于左右子树的值 ②子树也是最大堆 b.最小堆： ①根的值小于左右子树的值 ②子树也是最小堆 该模块提供了堆排序算法的实现,heapq有两种方式创建堆， 一种是使用一个空列表， 然后使用heapq.heappush()函数把值加入堆中，另外一种就是使用heap.heapify(list)转换列表成为堆结构 ##插入 import heapq #载入heap库，heap指的是最小堆 nums = [2, 3, 5, 1, 54, 23, 132] heap = [] for num in nums: heapq.heappush(heap, num) # 加入堆 print(heap[0]) # 如果只是想获取最小值而不是弹出，使用heap[0] print([heapq.heappop(heap) for _ in range(len(nums))]) # 堆排序结果 heap= [] nums = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(nums) print(nums) print([heapq.heappop(heap) for _ in range(len(nums))]) import math from io import StringIO def show_tree(tree, total_width=36, fill=' '): \"\"\"Pretty-print a tree.\"\"\" output = StringIO() last_row = -1 for i, n in enumerate(tree): if i: row = int(math.floor(math.log(i + 1, 2))) else: row = 0 if row != last_row: output.write('\\n') columns = 2 ** row col_width = int(math.floor(total_width / columns)) output.write(str(n).center(col_width, fill)) last_row = row print(output.getvalue()) print('-' * total_width) print() data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) ##删除 #heapq.heappop() data = [2, 3, 5, 1, 54, 23, 132] heapq.heapify(data) heap = [] while data: i=heapq.heappop(data) print('pop %3d:' % i) show_tree(data) heap.append(i) print(heap) import heapq nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] # print(heapq.nlargest(3, nums)) # Prints [42, 37, 23] # print(heapq.nsmallest(3, nums)) # portfolio = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price']) expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price']) ###最小堆转最大堆 只用对元素取负，按照最小堆的方式存储，取出来的值只要再取负，就是最大值了。即push(e)改为push(-e)，pop(e)为-pop(e) data = [2, 3, 5, 1, 54, 23, 132] heap = [] for n in data: print('add {:>3}:'.format(n)) heapq.heappush(heap, n) show_tree(heap) print(heap) heap1 = [] while heap: i=-1 * heapq.heappop(heap) print('pop %3d:' % i) show_tree(data) heap1.append(i) print(heap1) ####最大堆 实现一个优先级队列 import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] class Item: def __init__(self, name): self.name = name def __repr__(self): return 'Item({!r})'.format(self.name) q = PriorityQueue() q.push(Item('foo'), 1) q.push(Item('bar'), 5) q.push(Item('spam'), 4) q.push(Item('grok'), 1) q.pop() q.pop() q.pop() q.pop() "},"PythonShare/Regex.html":{"url":"PythonShare/Regex.html","title":"Regex","keywords":"","body":"Regex 模式匹配: 模式匹配是数据结构中字符串的一种基本运算, 给定一个子串, 要求在某个字符串中找出与该子串相同的所有子串 tips: 正则表达式使用反斜杠（'\\'）来表示特殊形式，或者把特殊字符转义成普通字符. 而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突. 比如说，要匹配一个字面上的反斜杠，正则表达式模式不得不写成 '\\\\\\\\'，因为正则表达式里匹配一个反斜杠必须是 \\\\ ，而每个反斜杠在普通的 Python 字符串里都要写成 \\\\ . 解决办法是对于正则表达式样式使用 Python 的原始字符串表示法: 在带有 'r' 前缀的字符串字面值中，反斜杠不必做任何特殊处理. 因此 r\"\\n\" 表示包含 '\\' 和 'n' 两个字符的字符串，而 \"\\n\" 则表示只包含一个换行符的字符串. 样式在 Python 代码中通常都会使用这种原始字符串表示法来表示. import re ## 不带'r'前缀 a = '''aaa\\\\bbbb''' re.split('\\\\\\\\',a) # ['aaa', 'bbbb'] ## 带'r'前缀 re.split(r'\\\\',a) # ['aaa', 'bbbb'] 正则表达式语法 用来检查某个字符串是否跟给定的正则表达式匹配 常用特殊字符及含义 . 匹配除了换行的任意字符 如果指定了标签 DOTALL (re.S, re.DOTALL)，它将匹配包括换行符的任意字符 ^ 匹配字符串的开头 $ 匹配字符串尾或者换行符的前一个字符 * 对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串 + 对它前面的正则式匹配1到任意次重复 ? 对它前面的正则式匹配0到1次重复 *?, +?, ?? '*', '+'和 '?' 修饰符都是贪婪的, 它们在字符串进行尽可能多的匹配 在修饰符之后添加 ? 将使样式以 非贪婪 方式进行匹配 , 尽量少的字符将会被匹配 {m-n} 对其之前的正则式指定匹配 m-n个重复 ,在 m 和 n 之间取尽量多 {m-n}? 上一个修饰符的非贪婪模式，只匹配尽量少的字符次数 \\ 转义特殊字符 [] 用于表示一个字符集合 | A|B A 和 B 可以是任意正则表达式, 一旦 A 匹配成功， B 就不再进行匹配 b,B s,S d,D w,W Z... 等特殊转义字符详解见 re正则表达式操作 模块 re.compile(pattern, flags=0) 将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 通过 re.compile()编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题. import re a = '''aaa\\nbbbb''' tmp = re.compile(r'(.*)\\n(.*)') tmp.match(a) ## ## 等价于 re.match(pattern=r'(.*)\\n(.*)', string=a, flags=0) flags: re.A(re.ASCII) 让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配ASCII，而不是Unicode re.DEBUG 显示编译时的debug信息 re.I(re.IGNORECASE) 进行忽略大小写匹配 re.S(re.DOTALL) 让 '.' 特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.' 就匹配除了换行符的其他任意字符 re.search(pattern, string, flags=0 ) 扫描整个字符串找到匹配样式的第一个位置, 并返回一个相应的匹配对象 如果没有匹配，就返回 None re.match(pattern, string, flags=0 ) 如果 string 开始的0或者多个字符匹配到了正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'.*b\\n') tmp.search(a) ## tmp.match(a) ## None re.fullmatch(pattern, string, flags=0 ) 如果整个 string 匹配到正则表达式样式, 就返回一个相应的匹配对象 如果没有匹配，就返回 None import re a = '''aaa\\naaa\\naaa''' tmp = re.compile(r'.*\\n.*\\n.*') tmp.fullmatch(a) ## re.split(pattern, string, flags=0 ) 用 pattern 分开 string , 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里. 如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素 re.split(r'\\W+', 'Words, words, words.', 1) # ['Words', 'words, words.'] re.findall(pattern, string, flags=0 ) 对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回. 如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）. 空匹配也会包含在结果里. import re a = '''aaa\\naab\\naac\\n''' re.findall(r'.+\\n.*?',a) ## ['aaa\\n', 'aab\\n', 'aac\\n'] re.finditer(pattern, string, flags=0 ) pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 . string 从左到右扫描，匹配按顺序排列. 空匹配也包含在结果里. import re a = '''aaa\\naab\\naac\\n''' c = [] [c.append(i.group(0)) for i in re.finditer(r'.+[a|b]\\n.*?',a)] print(c) ## ['aaa\\n', 'aab\\n'] re.sub(pattern, repl, string, count=0, flags=0) 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串. 如果样式没有找到，则不加改变地返回 string. repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理. 如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用. 这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串. re.subn(pattern, repl, string, count=0, flags=0) 行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数). 正则表达式对象 编译后的正则表达式对象支持的方法和属性 pattern = re.compile(\"\\n\") Pattern.search(string[, pos[, endpos]]) Pattern.match(string[, pos[, endpos]]) Pattern.fullmatch(string[, pos[, endpos]]) Pattern.split(string[, pos[, endpos]]) Pattern.findall(string[, pos[, endpos]]) Pattern.finditer(string[, pos[, endpos]]) Pattern.sub(string[, pos[, endpos]]) Pattern.subn(string[, pos[, endpos]]) Pattern.flags 正则匹配标记 Pattern.groups 捕获组合的数量 Pattern.groupindex 映射由 (?P) 定义的命名符号组合和数字组合的字典 如果没有符号组, 那字典就是空的 Pattern.pattern 编译对象的原始样式字符串 匹配对象 匹配对象总是有一个布尔值 True. 如果没有匹配的话 match() 和 search() 返回 None 所以可以用 if 语句来判断是否匹配 import re a = '''aaa\\naab\\naac\\n''' x = re.match(r'.+\\n.*?',a) if x: print(x.group()) ## aaa Match.group([group1, ...]) 返回一个或者多个匹配的子组. 如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项） 如果没有参数，组1默认到0（整个匹配都被返回） import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.group() ## 'aaa\\naab\\naaa' x.group(0) ## 'aaa\\n' x.group(1) ## 'aab\\n' Match.groups(default=None) 返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合. default 参数用于不参与匹配的情况，默认为 None. import re a = '''aaa\\naab\\naaa''' tmp = re.compile(r'(.*\\n)(.*\\n).*') x = tmp.search(a) x.groups() ## ('aaa\\n', 'aab\\n') Match.start([group]) Match.end([group]) 返回 group 匹配到的字串的开始和结束标号 x.start() ## 0 x.end () ## 11 Match.span([group]) 对于一个匹配 m, 返回一个二元组 (m.start(group), m.end(group)). 如果 group 没有在这个匹配中，就返回 (-1, -1). group 默认为0，就是整个匹配. x.span() ## (0, 11) x.span(1) ## (0, 4) x.span(2) ## (4, 8) Match.pos Match.endpos 正则引擎开始/停止在字符串搜索一个匹配的索引位置 Match.re 返回产生这个实例的 正则对象, 这个实例是由 正则对象的 match() 或 search() 方法产生的 Match.string 传递到 match() 或 search() 的字符串 "},"PythonShare/Numbers&Datatime.html":{"url":"PythonShare/Numbers&Datatime.html","title":"Numbers&Datatime","keywords":"","body":"Numbers&Datatime Numbers 数字的四舍五入 # 对于简单的舍入运算，使用内置的 round(value, ndigits) 函数 round(1.23, 1) round(1.27, 1) round(1.5,0) round(2.5,0) a = 1627731 round(a, -1) round(a, -2) # 简单的输出一定宽度的数,格式化的时候指定精度 x = 1.23456 format(x, '0.3f') print('value is {:0.3f}'.format(x)) 执行精确的浮点数运算 a = 4.2 b = 2.1 print(a + b==6.3) #底层 CPU 和 IEEE 754 标准通过自己的浮点单位去执行算术时导致 #decimal 模块更精确但损耗性能 from decimal import Decimal a = Decimal('4.2') b = Decimal('2.1') print(type(a + b)) Decimal('6.3')==a+b nums = [1.23e+18, 1, -1.23e+18] sum(nums) import math math.fsum(nums) 数字的格式化输出 x = 1234.56789 format(x, '0.2f') format(x, '>10.1f') format(x, ' 二八十六进制整数 # 为了将整数转换为二进制、八进制或十六进制的文本串，可以分别使用 bin(),oct() 或 hex() 函数： x = 1234 bin(x) oct(x) hex(x) # 不想输出 0b , 0o 或者 0x 的前缀的话，可以使用 format() 函数 format(x, 'b') format(x, 'o') format(x, 'x') # 不同的进制转换整数字符串，简单的使用带有进制的 int() 函数 int('4d2', 16) int('10011010010', 2) 字节到大整数的打包与解包 data = b'\\x00\\x124V\\x00x\\x90\\xab\\x00\\xcd\\xef\\x01\\x00#\\x004' ##字节字符串 #int.from_bytes(bytes, byteorder, *, signed=False) #参数解释： bytes是要转换的十六进制； #byteorder：选'big'和'little'，以上例为例，其中big代表正常顺序，即f1ff。little反之，代表反序fff1； #signed：选True、Flase表示是否要区分二进制的正负数含义。即是否要对原二进制数进行原码反码 补码操作。 int.from_bytes(data, 'little') int.from_bytes(data, 'big') x = 94522842520747284487117727783387188 x.to_bytes(16, 'big') x.to_bytes(16, 'little') x = 0x01020304 x.to_bytes(4, 'big') x.to_bytes(4, 'little') 复数的数学运算 j*2=-1 a = complex(2, 4) b = 3 - 5j a.real a.imag a.conjugate() ###共轭复数 两个实部相等，虚部互为相反数的复数互为共轭复数 a + b a * b a / b abs(a) import cmath cmath.sin(a) cmath.cos(a) cmath.exp(a) #Python 的标准数学函数确实情况下并不能产生复数值 math.sqrt(-1) cmath.sqrt(-1) 无穷大与 NaN #创建 a = float('inf') b = float('-inf') c = float('nan') d = float('nan') math.isinf(a) math.isnan(c) a + 45 a * 10 10 / a a/a a + b c + 23 c / 2 math.sqrt(c) print(c==d) 3.8,3.9,3.10 分数运算，大型数组运算，矩阵和线性代数运算 大家自己看看 随机选择 import random values = [1, 2, 3, 4, 5, 6] random.choice(values) ###一个元素 random.choice(values) random.sample(values, 2) ##多个元素 random.shuffle(values) ##打乱顺序 #生成随机整数 random.randint(0,10) #生成 0 到 1 范围内均匀分布的浮点数 random.random() #获取 N 位随机位 (二进制) 的整数 random.getrandbits(10) ###随机种子 random.seed(12345) Datatime 基本的日期与时间转换 from datetime import timedelta a = timedelta(days=2, hours=6) b = timedelta(hours=4.5) c = a + b c.days c.seconds c.seconds / 3600 c.total_seconds() / 3600 from datetime import datetime a = datetime(2012, 9, 23) print(a + timedelta(days=10)) #days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0 b = datetime(2012, 12, 21) d = b - a d d.days now = datetime.today() print(now) print(now + timedelta(minutes=10)) from dateutil.relativedelta import relativedelta a + relativedelta(months=+1) d = relativedelta(b, a) 计算最后一个周五的日期 from datetime import datetime from dateutil.relativedelta import relativedelta from dateutil.rrule import * print(d + relativedelta(weekday=FR(3))) "},"QuestionBank/":{"url":"QuestionBank/","title":"QuestionBank","keywords":"","body":"Introduction 定期选择力扣题目，共同研究学习，提高代码掌控力和逻辑思维能力，更好更快的写出优雅贵气的代码 "},"QuestionBank/20190807.html":{"url":"QuestionBank/20190807.html","title":"20190807","keywords":"","body":"from leetcode： Q:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb "}}